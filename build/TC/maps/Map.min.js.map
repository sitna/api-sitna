{"version":3,"sources":["Map.js"],"names":["TC","inherit","childCtor","parentCtor","prototype","Object","create","constructor","_super","mix","targetCtor","mixins","assign","this","CustomEvent","__p__","type","init","e","document","createEvent","initCustomEvent","bubbles","cancelable","detail","Element","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","onInternal","events","callback","options","self","split","forEach","evt","$events","addEventListener","result","cbParameter","target","currentTarget","keys","key","call","bind","_listeners","Map","set","EventTarget","createDocumentFragment","methods","method","push","etProto","on","navigator","userAgent","indexOf","one","newCallback","off","once","eventList","stack","has","removeEventListener","get","cb","clear","trigger","window","$","Event","ceOptions","event","dispatchEvent","_onBySelectorMap","WeakMap","listenerBySelector","selector","element","eventType","eventTypes","selectors","_listenerBySelectorCalled","elm","parentNode","currentState","previousState","jsonPackWorkerUrlPromise","jsonPackSettleFunctions","jsonpackProcess","action","json","Promise","resolve","reject","async","Util","getWebWorkerCrossOriginURL","apiLocation","jsonPackWorkerUrl","jsonPackWorker","Worker","onmessage","settleFunctions","data","id","error","terminate","getJsonPackWorker","then","worker","workId","getUID","postMessage","object","_addToHistory","state","_getMapState","replaceCurrent","history","replaceState","saveState","utf8ToBase64","pushState","location","href","shift","lastEventType","Consts","BASELAYERCHANGE","LAYERORDER","ZOOM","toLowerCase","layer","layerType","WMS","MAPCHANGE","crs","ext","getExtent","i","length","Math","abs","floor","entry","baseLayerData","baseLayers","filter","baseLayer","isRaster","fallbackLayer","map","fallbackLayerID","base","layers","workLayers","stateless","layerNames","u","isOnCapabilities","url","n","Array","isArray","names","join","o","getOpacity","v","getVisibility","h","hideTitle","ur","unremovable","f","Filter","getText","t","title","on3DView","view3D","cameraControls","vw3","getCameraState","extraStates","extend","cacheResult","_controlStatesCache","packed","catch","_loadIntoMap","stringOrJson","promises","loadingctrl","loadingCtrl","getControlsByClass","hasWait","addWait","resolved","removeWait","objPromise","res","rej","obj","err","JSON","parse","getLocaleString","locale","setProjection","oldCrs","extent","getLayer","getBaseLayer","setBaseLayer","firstOption","fbPromise","addLayer","getFallbackLayer","newLayer","setExtent","animate","removeLayer","capas","capa","layerInConfig","j","lyrCfg","renderOptions","opacity","hide","setVisibility","setOpacity","protocol","rootNode","wrap","getRootLayerNode","Title","all","getReduceByValueFunction","prop","value","prev","cur","idx","getAvailableBaseLayer","availableBaseLayers","Cfg","abl","div","_instances","isReady","isLoaded","controls","activeControl","vectors","loadingLayerCount","getDiv","_jQueryIsLoaded","_$div","classList","add","classes","LOADING","MAP","_markerPromises","_layerBuffer","contains","some","l","getIndex","reduce","zIndex","isBase","pending","splice","getIndexForZIndex","remove","getMapLayers","rejected","mapLayer","layerObj","index","VECTOR","layerId","getResolvedWorkLayerIndex","getResolvedVisibleLayerIndex","getReduceByZIndexFunction","checkMapLoad","concat","every","throwMapLoad","setLoaded","stateful","LAYERADD","LAYERREMOVE","LAYERVISIBILITY","eventsToMapChange","LAYERUPDATE","FEATUREADD","FEATUREREMOVE","FEATUREMODIFY","FEATURESADD","FEATURESCLEAR","fn_addToHistory","layerOpacityHandlerTimeout","LAYEROPACITY","clearTimeout","setTimeout","wait","toString","checkLocation","MAPLOAD","THREED","loadJS","view","ThreeD","apply","control","button","removeAttribute","onAvailables","lastResortBaseLayer","mustReproject","ready","Defaults","search","allowedSearchTypes","allowed","hasOwnProperty","mergeOptions","layout","LAYOUTLOAD","undefined","zoomToFeatures","handleFeaturesAdd","_zoomToFeaturesTimeout","features","_handleLayerAdd","loaded","initialExtent","maxExtent","defaultInfoContainer","PROJ4JSOBJ","proj4js","loadJSInOrder","OLNS","ol","olConnector","loadProjDef","setMap","ctlPromises","name","ctlOptions","querySelector","addControl","BEFORELAYERUPDATE","_triggerLayersBeforeUpdateEvent","_triggerLayersUpdateEvent","LAYERERROR","workLayer","stateLayer","toast","message","msgType","ERROR","finally","ctl","importControlStates","MAPREADY","setHeightFix","FEATURECLICK","isExclusive","feature","showInfo","NOFEATURECLICK","_noFeatureClicked","allLayersClicked","len","wl","Popup","p","isVisible","mapProto","getMapState","getPreviousMapState","hash","substr","base64ToUtf8","msgErrorMode","TOAST","detectIE","inValidState","defaultBaseLayer","cp","chpr","bcpd","BEFOREUPDATE","UPDATE","i18n","loadResources","condition","path","ajax","responseType","mimeType","response","currentLocale","currentLocaleKey","getBoundingClientRect","height","querySelectorAll","BEFORELAYOUTLOAD","layoutURLs","ignoreError","trim","match","config","markup","style","script","layoutPromises","ResponseError","status","onError","mapObj","EMAIL","i18nLayoutPromise","fetch","ok","onLine","linkElement","createElement","rel","head","appendChild","text","replace","grp1","grp2","grp3","insertAdjacentHTML","blob","fileBlob","fileURL","URL","createObjectURL","scriptElement","src","onload","UPDATEPARAMS","deleteTreeCache","oldError","subject","isDebug","console","trace","fnc","mode","warn","duration","toastDuration","loggingErrorsEnabled","JL","fatalException","msg","errorMsg","CONSOLE","instance","tree","mergeLayerOptions","optionsArray","propertyName","layerOptions","slice","log","layerOption","unshift","argArray","arguments","arg","elem","controlOptions","controlContainer","containerControl","mergeControlOptions","crsLayerError","reason","errorMessage","isValidFromNames","Error","getCRS","stealth","lyr","test","objUrl","Raster","Vector","Layer","KML","WFS","getMap","BEFORELAYERADD","TILELOADERROR","code","_tileloaderror","getPath","onTileload","tile","BLANK_IMAGE","TILELOAD","indexOfFirstVector","getLayerCount","currentCrs","isCompatible","baseLayerEndFn","isDefault","fit","WMTS","getCompatibleMatrixSets","parent","fitToExtent","ollyr","getCapabilitiesOnline","onlineCapabilities","capabilities","compatibleMatrixSet","setMatrixSet","insertLayer","isFunction","opt","projection","getView","getProjection","resolutions","getResolutions","minZoom","getMinZoom","maxZoom","getMaxZoom","minResolution","getMinResolution","maxResolution","getMaxResolution","Number","POSITIVE_INFINITY","setView","View","found","olLayer","beforeIdx","targetLayer","olLayers","olTargetLayer","olIdx","getLayerIndex","oldIndex","newIndex","setLayerIndex","putLayerOnTop","BEFOREBASELAYERCHANGE","oldLayer","VIEWCHANGE","getLayerTree","getTree","_addCtl","register","c","parentElement","CONTROLADD","toUpperCase","Control","classObj","namespaces","getControlById","getDefaultControl","candidate","defaultActiveControl","lastCtrlActive","getLoadingIndicator","ctls","setCenter","coord","getCenter","setRotation","rotation","getRotation","getViewHTML","getViewport","getCompatibleCRS","crsLists","normalized","includeFallback","includeFallbacks","otherCrsLists","crsList","loadProjections","getProjectionData","getCRSCode","responses","projList","number_result","projData","results","def","proj4","unit","orderBy","sort","getSorterByProperty","allowFallbackLayer","loadProj","_setProjection","layerProjectionOptions","setLayerProjection","resolveChange","PROJECTIONCHANGE","newCrs","getCapabilitiesPromise","getMetersPerUnit","getCoordinateFromPixel","xy","getPixelFromCoordinate","bounds","Infinity","opts","radius","pointBoundsRadius","extentMargin","b","getBounds","min","max","dx","dy","_on3DZoomTo","reprojected","ZOOMTO","coordsXY","view2DCRS","reproject","coordsXY2","zoomToMarkers","markers","Marker","zoomToLayer","_getVectors","addPoint","addMarker","marker","addPolyline","coords","addPolygon","getResolution","setResolution","resolution","exportFeatures","loadingCtl","waitId","elevSubst","format","GPX","NaN","getData","newData","innerHTML","innerText","unsetData","setData","flatCoords","getCoords","pointArray","point","newFeature","clone","setId","SHP","defaultEncoding","rv","x","lastIndexOf","getInnerType","proj","arrPromises","groups","CLASSNAME","group","_group","_features","curr","val","getStyle","label","geometries","Polyline","MultiPolyline","geometry","shpWrite","write","vacia","content","timestamp","fileName","substring","resolves","JSZip","zip","file","shp","buffer","shx","dbf","wkt","generateAsync","downloadBlob","GPKG","fieldDataType","geopackage","DataTypes","GPKG_DT_TEXT_NAME","GPKG_DT_INTEGER_NAME","GPKG_DT_FLOAT_NAME","GPKG_DT_BOOLEAN_NAME","fromName","require","myPackage","srs_id","getSpatialReferenceSystemDao","queryForId","srsDao","newSRS","createObject","srs_name","organization","organization_coordsys_id","definition","definition_12_063","description","FeatureColumn","GeometryColumns","geometryType","tableName","columns","createPrimaryKeyColumnWithIndexAndName","createGeometryColumn","attributes","fieldName","fieldValue","createColumnWithIndex","geometryColumns","table_name","column_name","geometry_type_name","z","getGeometryStride","m","boundingBox","BoundingBox","createFeatureTableWithGeometryColumns","featureDao","getFeatureDao","wkx","featureRow","newRow","geometryData","GeometryData","setSrsId","Geometry","WKT","writeFeature","setGeometry","setValueWithColumnName","y","export","empty","downloadFile","KMZ","replaceSpecialCharacters","filename","exportControlStates","exportState","controlStates","importState","toasts","toastHide","container","HIDDEN","removeChild","toastInfo","timeout","span","CLICK","passive","className","INFO","WARNING","mapHeightNeedsFix","ih","innerHeight","matchMedia","fix","toggle","IPAD_IOS7_FIX","exportImage","canvas","synchronous","getElementsByTagName","crossOrigin","toDataURL","getElevationTool","elevation","tool","Elevation","elevationOptions","services","googleMapsKey","service","isString","serviceName","magicFunction","availableLayers","describeFeatureType","returnObject","layerName","_filter","geometryFields","k","isGeometry","nillable","minOccurs","recursive","geomName","LogicalNary","conditions","Spatial","geometryName","geomNames","or","acc","getTagName","srsName","extractFeatures","outputFormat","download","layersToExtract","_getServiceTitle","mapLayers","Service","SRSDOWNLOAD_GEOJSON_KML","_postOrDownload","objlayer","toolProxification","cacheHost","getAction","cacheAction","objLayer","contentType","XMLDocument","exception","errors","WFSErrors","INDETERMINATE","params","getAttribute","errorThrown","textContent","_makePostCall","getDisgregatedLayerNames","availableNames","serviceObj","getInfo","queryable","request","getWFSCapabilities","_numMaxFeatures","layerList","Operations","FeatureTypes","titles","LAYERS_NOT_AVAILABLE","serviceTitle","GetFeature","CountDefault","DefaultValue","version","QueryExpressions","QUERY_NOT_AVAILABLE","DCPType","HTTP","Post","onlineResource","DCP","numMaxfeatures","urlData","WFSQueryBuilder","fetchXML","featFounds","parseInt","isNaN","MAX_NUM_FEATURES","NO_FEATURES","limit","NO_VALID_LAYERS","GETFEATURE_NOT_AVAILABLE","GETCAPABILITIES","updateSize","linkTo"],"mappings":"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","sourcesContent":["var TC = TC || {};\r\n\r\nTC.inherit = function (childCtor, parentCtor) {\r\n    childCtor.prototype = Object.create(parentCtor.prototype);\r\n    childCtor.prototype.constructor = childCtor;\r\n    childCtor._super = parentCtor.prototype;\r\n};\r\n\r\nTC.mix = function (targetCtor, ...mixins) {\r\n    Object.assign(targetCtor.prototype, ...mixins);\r\n};\r\n\r\n(function () {\r\n\r\n    // Polyfill de CustomEvent\r\n    /*! (c) Andrea Giammarchi - ISC */\r\n    var self = this || /* istanbul ignore next */ {};\r\n    self.CustomEvent = typeof CustomEvent === 'function' ?\r\n        CustomEvent :\r\n        (function (__p__) {\r\n            CustomEvent[__p__] = new CustomEvent('').constructor[__p__];\r\n            return CustomEvent;\r\n            function CustomEvent(type, init) {\r\n                if (!init) init = {};\r\n                var e = document.createEvent('CustomEvent');\r\n                e.initCustomEvent(type, !!init.bubbles, !!init.cancelable, init.detail);\r\n                return e;\r\n            }\r\n        }('prototype'));\r\n\r\n    if (!Element.prototype.matches) {\r\n        Element.prototype.matches =\r\n            Element.prototype.matchesSelector ||\r\n            Element.prototype.mozMatchesSelector ||\r\n            Element.prototype.msMatchesSelector ||\r\n            Element.prototype.oMatchesSelector ||\r\n            Element.prototype.webkitMatchesSelector;\r\n    }\r\n\r\n    const getNativeListener = function (evt, callback) {\r\n        const result = function (evt) {\r\n            const cbParameter = {\r\n                type: evt.type,\r\n                target: this,\r\n                currentTarget: this\r\n            };\r\n            if (evt.detail) {\r\n                Object.keys(evt.detail).forEach(function (key) {\r\n                    if (!(key in cbParameter)) {\r\n                        cbParameter[key] = evt.detail[key];\r\n                    }\r\n                });\r\n            }\r\n            return callback.call(this, cbParameter);\r\n        }.bind(this);\r\n        const stack = this._listeners[evt] = this._listeners[evt] || new Map();\r\n        stack.set(callback, result);\r\n        return result;\r\n    };\r\n\r\n    const onInternal = function (events, callback, options) {\r\n        const self = this;\r\n        events.split(' ').forEach(function (evt) {\r\n            self.$events.addEventListener(evt, getNativeListener.call(self, evt, callback), options);\r\n        });\r\n        return self;\r\n    };\r\n\r\n    TC.EventTarget = function () {\r\n        const self = this;\r\n        self._listeners = {};\r\n        self.$events = document.createDocumentFragment();\r\n\r\n        const delegate = function (method) {\r\n            this[method] = self.$events[method].bind(self.$events);\r\n        };\r\n        const methods = [\r\n            'addEventListener',\r\n            'dispatchEvent',\r\n            'removeEventListener'\r\n        ];\r\n        methods.forEach(delegate, self);\r\n\r\n        const fill$events = function (method) {\r\n            self.$events[method] = self[method].bind(self);\r\n        };\r\n        methods.push('on');\r\n        methods.push('one');\r\n        methods.push('off');\r\n        methods.push('trigger');\r\n        methods.forEach(fill$events, self);\r\n    };\r\n\r\n    const etProto = TC.EventTarget.prototype;\r\n\r\n    etProto.on = function (events, callback) {\r\n        return onInternal.call(this, events, callback);\r\n    };\r\n\r\n    if (navigator.userAgent.indexOf(\"Trident\") >= 0 || navigator.userAgent.indexOf(\"MSIE\") >= 0) {\r\n        // Parche para IE\r\n        etProto.one = function (events, callback) {\r\n            const self = this;\r\n            const newCallback = function (e) {\r\n                self.off(events, newCallback);\r\n                callback.call(this, e);\r\n            };\r\n            self.on(events, newCallback);\r\n            return self;\r\n        };\r\n    } else {\r\n        etProto.one = function (events, callback) {\r\n            return onInternal.call(this, events, callback, { once: true });\r\n        };\r\n    }\r\n\r\n    etProto.off = function (events, callback) {\r\n        const self = this;\r\n        const eventList = events.split(' ');\r\n        if (callback) {\r\n            eventList.forEach(function (evt) {\r\n                const stack = self._listeners[evt];\r\n                if (stack && stack.has(callback)) {\r\n                    self.$events.removeEventListener(evt, stack.get(callback));\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            eventList.forEach(function (evt) {\r\n                const stack = self._listeners[evt];\r\n                if (stack) {\r\n                    stack.forEach(function (cb) {\r\n                        self.$events.removeEventListener(evt, cb);\r\n                    });\r\n                    stack.clear();\r\n                }\r\n            });\r\n        }\r\n        return self;\r\n    };\r\n\r\n    etProto.trigger = function (type, options) {\r\n        const self = this;\r\n        //Compatibilidad hacia atrs\r\n        if (window.$ && $.Event && type instanceof $.Event) {\r\n            options = {};\r\n            Object.keys(type).forEach(function (key) {\r\n                if (key !== 'type') {\r\n                    options[key] = type[key];\r\n                }\r\n            });\r\n            type = type.type;\r\n        }\r\n        var ceOptions;\r\n        if (options) {\r\n            ceOptions = {\r\n                detail: options\r\n            };\r\n        }\r\n        const event = new CustomEvent(type, ceOptions);\r\n        self.dispatchEvent(event);\r\n    };\r\n\r\n    TC.EventTarget._onBySelectorMap = new WeakMap();\r\n\r\n    TC.EventTarget.listenerBySelector = function (selector, callback) {\r\n        // Crea una estructura a partir de un mapa cuyas claves son los elementos.\r\n        // Los valores son objetos cuyas claves son tipos de eventos\r\n        // y cuyos valores son objetos que tienen como claves los selectores\r\n        // y cuyos valores son las funciones de callback.\r\n        // Se crea una funcin que va buscando la primera correspondencia con un selector.\r\n        // En cuanto la encuentra, ejecuta el callback y deja de procesar.\r\n        return function (e) {\r\n            const element = this;\r\n            const eventType = e.type;\r\n            var eventTypes = TC.EventTarget._onBySelectorMap.get(element);\r\n            if (!eventTypes) {\r\n                eventTypes = {};\r\n                TC.EventTarget._onBySelectorMap.set(element, eventTypes);\r\n            }\r\n            var selectors = eventTypes[eventType];\r\n            if (!selectors) {\r\n                eventTypes[eventType] = selectors = {};\r\n            }\r\n            if (!selectors[selector]) {\r\n                selectors[selector] = callback;\r\n            }\r\n            // Para cada evento en cada elemento hay que llamar una sola vez al callback que toque.\r\n            // As que si se ejecuta un callback, prohibimos al resto de los listeners resolverse.\r\n            if (!e._listenerBySelectorCalled) {\r\n                var matches = false;\r\n                var elm = e.target;\r\n                var result;\r\n                while (elm && elm !== element) {\r\n                    for (selector in selectors) {\r\n                        if (elm.matches && elm.matches(selector)) {\r\n                            matches = true;\r\n                            result = selectors[selector].call(element, e);\r\n                            e._listenerBySelectorCalled = true;\r\n                        }\r\n                    }\r\n                    if (matches) {\r\n                        return result;\r\n                    }\r\n                    elm = elm.parentNode;\r\n                }\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * <p>Objeto principal de la API, instancia un mapa dentro de un elemento del DOM. Ntese que el constructor es asncrono, por tanto cualquier cdigo que haga uso de este objeto debera\r\n     * estar dentro de una funcin de callback pasada como parmetro al mtodo {{#crossLink \"TC.Map/loaded:method\"}}{{/crossLink}}.</p>\r\n     * <p>Puede consultar tambin online el <a href=\"../../examples/Map.1.html\">ejemplo 1</a>, el <a href=\"../../examples/Map.2.html\">ejemplo 2</a> y el <a href=\"../../examples/Map.3.html\">ejemplo 3</a>.</p>\r\n     * @class TC.Map\r\n     * @constructor\r\n     * @async\r\n     * @param {HTMLElement|string} div Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.\r\n     * @param {object} [options] Objeto de opciones de configuracin del mapa. Sus propiedades sobreescriben el objeto de configuracin global {{#crossLink \"TC.Cfg\"}}{{/crossLink}}.\r\n     * @param {string} [options.crs=\"EPSG:25830\"] Cdigo EPSG del sistema de referencia espacial del mapa.\r\n     * @param {array} [options.initialExtent] Extensin inicial del mapa definida por x mnima, y mnima, x mxima, y mxima. \r\n     * Esta opcin es obligatoria si el sistema de referencia espacial del mapa es distinto del sistema por defecto (ver TC.Cfg.{{#crossLink \"TC.Cfg/crs:property\"}}{{/crossLink}}).\r\n     * Para ms informacin consultar TC.Cfg.{{#crossLink \"TC.Cfg/initialExtent:property\"}}{{/crossLink}}.\r\n     * @param {array} [options.maxExtent] Extensin mxima del mapa definida por x mnima, y mnima, x mxima, y mxima. Para ms informacin consultar TC.Cfg.{{#crossLink \"TC.Cfg/maxExtent:property\"}}{{/crossLink}}.\r\n     * @param {string} [options.layout] URL de una carpeta de maquetacin. Consultar TC.Cfg.{{#crossLink \"TC.Cfg/layout:property\"}}{{/crossLink}} para ver instrucciones de uso de maquetaciones.\r\n     * @param {array} [options.baseLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink \"TC.cfg.LayerOptions\"}}{{/crossLink}} para incluir dichas capas como mapas de fondo. \r\n     * @param {array} [options.workLayers] Lista de identificadores de capa o instancias de la clase {{#crossLink \"TC.cfg.LayerOptions\"}}{{/crossLink}} para incluir dichas capas como contenido del mapa. \r\n     * @param {TC.cfg.MapControlOptions} [options.controls] Opciones de controles de mapa.\r\n     * @param {TC.cfg.StyleOptions} [options.styles] Opciones de estilo de entidades geogrficas.\r\n     * @param {string} [options.locale=\"es-ES\"] Cdigo de idioma de la interfaz de usuario. Este cdigo debe ser obedecer la sintaxis definida por la <a href=\"https://en.wikipedia.org/wiki/IETF_language_tag\">IETF</a>.\r\n     * Los valores posibles son <code>es-ES</code>, <code>eu-ES</code> y <code>en-US</code>.\r\n     * @param {string} [options.proxy] URL del proxy utilizado para peticiones a dominios remotos (ver TC.Cfg.{{#crossLink \"TC.Cfg/proxy:property\"}}{{/crossLink}}).\r\n     * @example\r\n     *     <div id=\"mapa\"/>\r\n     *     <script>\r\n     *         // Crear un mapa con las opciones por defecto.\r\n     *         var map = new TC.Map(\"mapa\");\r\n     *     </script>\r\n     * @example\r\n     *     <div id=\"mapa\"/>\r\n     *     <script>\r\n     *         // Crear un mapa en el sistema de referencia WGS 84 con el de mapa de fondo.\r\n     *         var map = new TC.Map(\"mapa\", {\r\n     *             crs: \"EPSG:4326\",\r\n     *             initialExtent: [ // Coordenadas en grados decimales, porque el sistema de referencia espacial es WGS 84.\r\n     *                 -2.84820556640625,\r\n     *                 41.78912492257675,\r\n     *                 -0.32135009765625,\r\n     *                 43.55789822064767\r\n     *             ],\r\n     *             maxExtent: [\r\n     *                 -2.84820556640625,\r\n     *                 41.78912492257675,\r\n     *                 -0.32135009765625,\r\n     *                 43.55789822064767\r\n     *             ],\r\n     *             baseLayers: [\r\n     * \t\t\t\tTC.Consts.layer.IDENA_DYNBASEMAP\r\n     *             ]\r\n     *         });\r\n     *     </script>\r\n     * @example\r\n     *     <div id=\"mapa\"></div>\r\n     *     <script>\r\n     *         // Crear un mapa que tenga como contenido las capas de toponimia y mallas cartogrficas del WMS de IDENA.\r\n     *         var map = new TC.Map(\"mapa\", {\r\n     *             workLayers: [\r\n     *                 {\r\n     *                     id: \"topo_mallas\",\r\n     *                     title: \"Toponimia y mallas cartogrficas\",\r\n     *                     type: TC.Consts.layerType.WMS,\r\n     *                     url: \"//idena.navarra.es/ogc/wms\",\r\n     *                     layerNames: \"IDENA:toponimia,IDENA:mallas\"\r\n     *                 }\r\n     *             ]\r\n     *         });\r\n     *     </script>\r\n     */\r\n\r\n    var currentState = null;\r\n    var previousState = null;\r\n    const _setupStateControl = function () {\r\n        const self = this;\r\n\r\n        var MIN_TIMEOUT_VALUE = 4;\r\n\r\n        // eventos a los que estamos suscritos para obtener el estado            \r\n        var events = [\r\n            TC.Consts.event.LAYERADD,\r\n            TC.Consts.event.LAYERORDER,\r\n            TC.Consts.event.LAYERREMOVE,\r\n            //TC.Consts.event.LAYEROPACITY, // Este evento lo vamos a tratar por separado, para evitar exceso de actualizaciones de estado.\r\n            TC.Consts.event.LAYERVISIBILITY,\r\n            TC.Consts.event.ZOOM,\r\n            TC.Consts.event.BASELAYERCHANGE].join(' ');\r\n\r\n        // gestin siguiente - anterior\r\n\r\n        let eventsToMapChange = [\r\n            TC.Consts.event.LAYERUPDATE,\r\n            TC.Consts.event.FEATUREADD,\r\n            TC.Consts.event.FEATUREREMOVE,\r\n            TC.Consts.event.FEATUREMODIFY,\r\n            TC.Consts.event.FEATURESADD,\r\n            TC.Consts.event.FEATURESCLEAR\r\n        ].join(' ');\r\n\r\n        self.on(eventsToMapChange, () => self.trigger(TC.Consts.event.MAPCHANGE));\r\n\r\n        // registramos el estado inicial                \r\n        self.replaceCurrent = true;\r\n        _addToHistory.call(self);\r\n\r\n        const fn_addToHistory = _addToHistory.bind(self);\r\n\r\n        // nos suscribimos a los eventos para registrar el estado en cada uno de ellos\r\n        self.on(events, fn_addToHistory);\r\n\r\n        // a la gestin del evento de opacidad le metemos un retardo, para evitar que haya un exceso de actualizaciones de estado.\r\n        var layerOpacityHandlerTimeout;\r\n        self.on(TC.Consts.event.LAYEROPACITY, function (e) {\r\n            clearTimeout(layerOpacityHandlerTimeout);\r\n            layerOpacityHandlerTimeout = setTimeout(function () {\r\n                _addToHistory.call(self, e);\r\n            }, 500);\r\n        });\r\n\r\n        // gestin siguiente - anterior\r\n        window.addEventListener('popstate', function (e) {\r\n            var wait;\r\n            wait = self.loadingCtrl && self.loadingCtrl.addWait();\r\n            setTimeout(async function () {\r\n                if (e) {\r\n                    // eliminamos la suscripcin para no registrar el cambio de estado que vamos a provocar\r\n                    self.off(events, fn_addToHistory);\r\n\r\n                    var state = e.state;\r\n                    if (Object.prototype.toString.call(state) === '[object Object]') {\r\n                        state = await self.checkLocation();\r\n                    }\r\n\r\n                    // gestionamos la actualizacin para volver a suscribirnos a los eventos del mapa                        \r\n                    _loadIntoMap.call(self, state).then(function () {\r\n                        setTimeout(function () {\r\n                            self.on(events, fn_addToHistory);\r\n                        }, 200);\r\n                        self.loadingCtrl && self.loadingCtrl.removeWait(wait);\r\n                    });\r\n                }\r\n            }, MIN_TIMEOUT_VALUE);\r\n        });\r\n    };\r\n\r\n    let jsonPackWorkerUrlPromise;\r\n    const jsonPackSettleFunctions = {};\r\n    const getJsonPackWorker = async function () {\r\n        if (!jsonPackWorkerUrlPromise) {\r\n            jsonPackWorkerUrlPromise = TC.Util.getWebWorkerCrossOriginURL(TC.apiLocation + 'TC/workers/tc-jsonpack-web-worker.js');\r\n        }\r\n        const jsonPackWorkerUrl = await jsonPackWorkerUrlPromise;\r\n        const jsonPackWorker = new Worker(jsonPackWorkerUrl);\r\n        jsonPackWorker.onmessage = function (e) {\r\n            const settleFunctions = jsonPackSettleFunctions[e.data.id];\r\n            if (settleFunctions) {\r\n                if (e.data.error) {\r\n                    settleFunctions.reject(e.data.error);\r\n                }\r\n                else {\r\n                    settleFunctions.resolve(e.data.result);\r\n                }\r\n                jsonPackWorker.terminate();\r\n                delete jsonPackSettleFunctions[e.data.id];\r\n            }\r\n        };\r\n        return jsonPackWorker;\r\n    };\r\n\r\n    const jsonpackProcess = function (action, json) {\r\n        return new Promise(function (resolve, reject) {\r\n            getJsonPackWorker().then(function (worker) {\r\n                const workId = TC.getUID();\r\n                jsonPackSettleFunctions[workId] = { resolve: resolve, reject: reject };\r\n                worker.postMessage({\r\n                    id: workId,\r\n                    action: action,\r\n                    object: json\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    const _addToHistory = async function (e) {\r\n        const self = this;\r\n\r\n        var state = await _getMapState.call(self);\r\n        if (self.replaceCurrent) {\r\n            window.history.replaceState(state, null, null);\r\n            delete self.replaceCurrent;\r\n\r\n            return;\r\n        } else {\r\n\r\n            /*if (self.registerState != undefined && !self.registerState) {\r\n                self.registerState = true;\r\n                return;\r\n            }*/\r\n\r\n            var saveState = function () {\r\n                previousState = currentState;\r\n                currentState = TC.Util.utf8ToBase64(state);\r\n                if (currentState !== previousState) {\r\n                    window.history.pushState(state, null, window.location.href.split('#').shift() + '#' + currentState);\r\n                }\r\n            };\r\n\r\n            if (e) {\r\n                self.lastEventType = e.type;\r\n\r\n                switch (true) {\r\n                    case (e.type == TC.Consts.event.BASELAYERCHANGE):\r\n                    case (e.type == TC.Consts.event.LAYERORDER):\r\n                    case (e.type == TC.Consts.event.ZOOM):\r\n                        saveState();\r\n                        break;\r\n                    case (e.type.toLowerCase().indexOf(\"LAYER\".toLowerCase()) > -1):\r\n                        // unicamente modifico el hash si la capa es WMS\r\n                        if (e.layer.type == TC.Consts.layerType.WMS)\r\n                            saveState();\r\n                        break;\r\n                }\r\n\r\n                self.trigger(TC.Consts.event.MAPCHANGE);\r\n            }\r\n        }\r\n    };\r\n\r\n    const _getMapState = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        return new Promise(function (resolve, reject) {\r\n            var state = {};\r\n\r\n            if (self.crs !== self.options.crs) {\r\n                state.crs = self.crs;\r\n            }\r\n\r\n            var ext = self.getExtent();\r\n            for (var i = 0; i < ext.length; i++) {\r\n                if (Math.abs(ext[i]) > 180)\r\n                    ext[i] = Math.floor(ext[i] * 1000) / 1000;\r\n            }\r\n            state.ext = ext;\r\n\r\n            //determinar capa base\r\n            var baseLayerData = [];\r\n\r\n            // es una capa de respaldo?\r\n            if (self.baseLayers) {\r\n                baseLayerData = self.baseLayers.filter(function (baseLayer) {\r\n                    return baseLayer.isRaster() && baseLayer.fallbackLayer;\r\n                }).map(function (baseLayer) {\r\n                    return {\r\n                        baseLayer: baseLayer, fallbackLayerID: baseLayer.fallbackLayer.id\r\n                    };\r\n                }).filter(function (baseLayerData) {\r\n                    return baseLayerData.fallbackLayerID === (self.baseLayer ? self.baseLayer.id : self.baseLayers[0].id);\r\n                });\r\n            }\r\n\r\n            if (baseLayerData.length > 0) {\r\n                state.base = baseLayerData[0].baseLayer.id;\r\n            } else if (self.baseLayer || (self.baseLayers && self.baseLayers[0])) {\r\n                state.base = (self.baseLayer || self.baseLayers[0]).id;\r\n            }\r\n\r\n            //capas cargadas\r\n            state.layers = [];\r\n\r\n            var layer, entry;\r\n            for (var i = 0; i < self.workLayers.length; i++) {\r\n                layer = self.workLayers[i];\r\n                if (layer.type == \"WMS\" && !layer.options.stateless) {\r\n                    if (layer.layerNames && layer.layerNames.length) {\r\n                        entry = {\r\n                            u: TC.Util.isOnCapabilities(layer.url),\r\n                            n: Array.isArray(layer.names) ? layer.names.join(',') : layer.names,\r\n                            o: layer.getOpacity(),\r\n                            v: layer.getVisibility(),\r\n                            h: layer.options.hideTitle,\r\n                            ur: layer.unremovable,\r\n                            f: layer.filter && (layer.filter instanceof TC.filter.Filter ? layer.filter.getText() : layer.filter),\r\n                            t: layer.title,\r\n                        };\r\n\r\n                        state.layers.push(entry);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (self.on3DView && self.view3D.cameraControls) {\r\n                state.vw3 = self.view3D.cameraControls.getCameraState();\r\n            }\r\n\r\n            if (options.extraStates) {\r\n                TC.Util.extend(state, options.extraStates);\r\n            }\r\n\r\n            if (!options.cacheResult && self._controlStatesCache) {\r\n                delete self._controlStatesCache;\r\n            }\r\n            if (self._controlStatesCache) {\r\n                resolve(self._controlStatesCache);\r\n            }\r\n            else {\r\n                jsonpackProcess('pack', state)\r\n                    .then(packed => {\r\n                        if (options.cacheResult) {\r\n                            self._controlStatesCache = packed;\r\n                        }\r\n                        resolve(packed);\r\n                    })\r\n                    .catch(error => reject(error));\r\n            }\r\n        });\r\n    };\r\n\r\n    const _clearMap = function () {\r\n        const self = this;\r\n\r\n        self.workLayers.filter(function (layer) {\r\n            return !(layer instanceof (TC.layer.Vector));\r\n        }).forEach(function (layer) {\r\n            if (layer.unremovable) {\r\n                layer.unremovable = false;\r\n            }\r\n            self.removeLayer(layer);\r\n        });\r\n    };\r\n    const _loadIntoMap = function (stringOrJson) {\r\n        const self = this;\r\n        const promises = [];\r\n\r\n        if (!stringOrJson) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (!self.loadingctrl) {\r\n            self.loadingCtrl = self.getControlsByClass(\"TC.control.LoadingIndicator\")[0];\r\n        }\r\n\r\n        if (!self.hasWait) {\r\n            self.hasWait = self.loadingCtrl && self.loadingCtrl.addWait();\r\n        }\r\n\r\n        // GLS lo aado para poder gestionar el final de la actualizacin de estado y volver a suscribirme a los eventos del mapa\r\n        return new Promise(function (resolve, reject) {\r\n            var resolved = function () {\r\n                self.loadingCtrl && self.loadingCtrl.removeWait(self.hasWait);\r\n                delete self.hasWait;\r\n                resolve();\r\n            };\r\n\r\n            let objPromise;\r\n            if (typeof (stringOrJson) == \"string\") {\r\n                objPromise = new Promise(function (res, rej) {\r\n                    jsonpackProcess('unpack', stringOrJson)\r\n                        .then(obj => res(obj))\r\n                        .catch(err => res(JSON.parse(stringOrJson)))\r\n                        .catch(err => {\r\n                            TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'));\r\n                            rej(err);\r\n                        });\r\n                });\r\n            } else {\r\n                objPromise = Promise.resolve(stringOrJson);\r\n            }\r\n\r\n            objPromise.then(function (obj) {\r\n                // CRS\r\n                if ((obj.crs && obj.crs !== self.crs) || (typeof obj.crs === 'undefined' && self.crs !== self.options.crs)) {\r\n                    promises.push(self.setProjection({\r\n                        crs: obj.crs || self.options.crs,\r\n                        oldCrs: self.crs,\r\n                        extent: obj.ext,\r\n                        baseLayer: self.getLayer(obj.base)\r\n                    }));\r\n                }\r\n                else {\r\n                    //capa base\r\n                    if (obj.base != self.getBaseLayer().id) {\r\n                        if (self.getLayer(obj.base)) {\r\n                            self.setBaseLayer(obj.base);\r\n                        }\r\n                        const firstOption = self.baseLayers.filter(function (baseLayer) {\r\n                            return baseLayer.options.fallbackLayer === obj.base;\r\n                        })[0];\r\n                        if (firstOption) {\r\n                            const fbPromise = self.addLayer(firstOption.getFallbackLayer());\r\n                            promises.push(fbPromise);\r\n                            fbPromise.then(function (newLayer) {\r\n                                self.setBaseLayer(newLayer);\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    //extent\r\n                    if (obj.ext) {\r\n                        promises.push(self.setExtent(obj.ext, { animate: false }));\r\n                    }\r\n                }\r\n\r\n                //capas cargadas        \r\n                //borrar primero\r\n                _clearMap.call(self);\r\n\r\n                obj.layers = obj.layers || obj.capas || [];\r\n\r\n                if (obj.layers.length > 0) {\r\n\r\n                    for (var i = 0; i < obj.layers.length; i++) {\r\n                        var capa = obj.layers[i];\r\n\r\n                        var layerInConfig = false;\r\n\r\n                        for (j = 0; j < self.options.workLayers.length; j++) {\r\n                            var lyrCfg = TC.Util.extend({}, self.options.workLayers[j], { map: self });\r\n\r\n                            if (capa.u === lyrCfg.url && lyrCfg.layerNames.indexOf(capa.n) >= 0) {\r\n                                layerInConfig = true;\r\n                                lyrCfg.renderOptions = { \"opacity\": capa.o, \"hide\": !capa.v };\r\n                                lyrCfg.unremovable = capa.ur;\r\n                                lyrCfg.title = capa.t;\r\n                                promises.push(self.addLayer(lyrCfg).then(function (layer) {\r\n                                    layer.setVisibility(this.v);\r\n                                    layer.setOpacity(this.o, true);\r\n                                }.bind(capa)));\r\n                            }\r\n                        }\r\n\r\n                        if (!layerInConfig) {\r\n                            promises.push(self.addLayer({\r\n                                id: TC.getUID(),\r\n                                url: TC.Util.isOnCapabilities(capa.u, capa.u.indexOf(window.location.protocol) < 0) || capa.u,\r\n                                hideTitle: capa.h,\r\n                                layerNames: capa.n ? capa.n.split(',') : \"\",\r\n                                unremovable: capa.ur,\r\n                                title: capa.t,\r\n                                renderOptions: {\r\n                                    opacity: capa.o,\r\n                                    hide: !capa.v\r\n                                }\r\n                            }).then(function (layer) {\r\n                                var rootNode = layer.wrap.getRootLayerNode();\r\n                                layer.title = rootNode.Title || rootNode.title;\r\n                                /*URI:el setOpacity recibe un nuevo parametro. Que indica si se no se va a lanzar evento LAYEROPACITY\r\n                                esto es porque en el loadstate al establecer la opacidad dedido a un timeout pasados X segundos se lanzaba \r\n                                este evento y produca un push en el state innecesario*/\r\n                                layer.setOpacity(this.o, true);\r\n                                layer.setVisibility(this.v);\r\n                            }.bind(capa)));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                Promise.all(promises)\r\n                    .then(function () {\r\n                        resolved();\r\n                    })\r\n                    .catch(function () {\r\n                        resolved();\r\n                    });\r\n            })\r\n                .catch(err => resolved());\r\n        });\r\n    };\r\n\r\n    const getReduceByValueFunction = function (prop, value) {\r\n        return function (prev, cur, idx) {\r\n            return cur[prop] === value ? idx : prev;\r\n        };\r\n    };\r\n\r\n    const getReduceByZIndexFunction = function (zIndex) {\r\n        return function (prev, cur, idx) {\r\n            return cur.zIndex <= zIndex ? idx : prev;\r\n        };\r\n    };\r\n\r\n    const getAvailableBaseLayer = function (id) {\r\n        const ablCollection = this instanceof TC.Map ? this.options.availableBaseLayers : TC.Cfg.availableBaseLayers;\r\n        return ablCollection.filter(function (abl) {\r\n            return abl.id === id;\r\n        })[0];\r\n    };\r\n\r\n    TC.Map = TC.Map || function (div, options) {\r\n        ///<summary>\r\n        ///Constructor\r\n        ///</summary>\r\n        ///<param name=\"div\" type=\"HTMLElement|string\">Elemento del DOM en el que crear el mapa o valor de atributo id de dicho elemento.</param>\r\n        ///<param name=\"options\" type=\"object\" optional=\"true\">Objeto de opciones de configuracin del mapa. Sus propiedades sobreescriben el objeto de configuracin global TC.Cfg.</param>\r\n        ///<returns type=\"TC.Map\"></returns>\r\n        ///<field name='isReady' type='boolean'>Indica si todos los controles del mapa estn cargados.</field>\r\n        ///<field name='isLoaded' type='boolean' default='false'>Indica si todos los controles y todas las capas del mapa estn cargados.</field>\r\n        ///<field name='activeControl' type='TC.Control'>Control que est activo en el mapa, y que por tanto responder a los eventos de ratn en su rea de visualizacin.</field>\r\n        ///<field name='layers' type='array' elementType='TC.Layer'>Lista de todas las capas base cargadas en el mapa.</field>\r\n        ///<field name='controls' type='array' elementType='TC.Control'>Lista de todos los controles del mapa.</field>\r\n        const self = this;\r\n        TC.EventTarget.call(self);\r\n        TC.Map._instances.push(self);\r\n\r\n        //TC.Object.apply(self, arguments);\r\n\r\n        /**\r\n         * Indica si todos los controles del mapa estn cargados.\r\n         * @property isReady\r\n         * @type boolean\r\n         * @default false\r\n         */\r\n        self.isReady = false;\r\n\r\n        /**\r\n         * Indica si todos los controles y todas las capas del mapa estn cargados.\r\n         * @property isLoaded\r\n         * @type boolean\r\n         * @default false\r\n         */\r\n        self.isLoaded = false;\r\n\r\n        /**\r\n         * Lista de todos los controles del mapa.\r\n         * @property controls\r\n         * @type array\r\n         * @default []\r\n         */\r\n        self.controls = [];\r\n\r\n        /**\r\n         * Control que est activo en el mapa, y que por tanto responder a los eventos de ratn en su rea de visualizacin.\r\n         * @property activeControl\r\n         * @type TC.Control\r\n         * @default null\r\n         */\r\n        self.activeControl = null;\r\n\r\n        /**\r\n         * Lista de todas las capas cargadas en el mapa.\r\n         * @property layers\r\n         * @type array\r\n         * @default []\r\n         */\r\n        self.layers = [];\r\n\r\n        /**\r\n         * Lista de todas las capas base cargadas en el mapa.\r\n         * @property baseLayers\r\n         * @type array\r\n         * @default []\r\n         */\r\n        self.baseLayers = [];\r\n\r\n        /**\r\n         * Lista de todas las capas de trabajo cargadas en el mapa.\r\n         * @property workLayers\r\n         * @type array\r\n         * @default []\r\n         */\r\n        self.workLayers = [];\r\n\r\n        /**\r\n         * Capa base actual del mapa.\r\n         * @property baseLayer\r\n         * @type TC.Layer\r\n         */\r\n        self.baseLayer = null;\r\n\r\n        /**\r\n         * Capa donde se dibujan las entidades geogrficas si no se especifica la capa explcitamente. Se instancia en el momento de aadir la primera entidad.\r\n         * @property vectors\r\n         * @type TC.layer.Vector\r\n         * @default null\r\n         */\r\n        self.vectors = null;\r\n\r\n        var loadingLayerCount = 0;\r\n        /**\r\n         * Elemento del DOM donde se ha creado el mapa.\r\n         * @property div\r\n         * @type HTMLElement\r\n         */\r\n        self.div = TC.Util.getDiv(div);\r\n        if (TC._jQueryIsLoaded) {\r\n            self._$div = $(self.div);\r\n        }\r\n        /**\r\n         * El mapa ha cargado todas sus capas iniciales y todos sus controles\r\n         * @event MAPLOAD\r\n         */\r\n        /**\r\n         * El mapa ha cargado todos sus controles, pero no hay garanta de que estn cargadas las capas\r\n         * @event MAPREADY\r\n         */\r\n        /**\r\n         * Se va a aadir una capa al mapa.\r\n         * @event BEFORELAYERADD\r\n         * @param {TC.Layer} layer Capa que se va a aadir.\r\n         */\r\n        /**\r\n         * Se ha aadido una capa al mapa.\r\n         * @event LAYERADD\r\n         * @param {TC.Layer} layer Capa que se ha aadido.\r\n         */\r\n        /**\r\n         * Se ha eliminado una capa del mapa.\r\n         * @event LAYERREMOVE\r\n         * @param {TC.Layer} layer Capa que se ha eliminado.\r\n         */\r\n        /**\r\n         * Se ha cambiado de posicin una capa en la lista de capas del mapa.\r\n         * @event LAYERORDER\r\n         * @param {TC.Layer} layer Capa que se ha eliminado.\r\n         * @param {number} oldIndex ndice de la posicin antes del cambio.\r\n         * @param {number} newIndex ndice de la posicin despus del cambio.\r\n         */\r\n        /**\r\n         * Se va a actualizar una capa del mapa: se van a modificar sus entidades o se va solicitar una nueva imagen.\r\n         * @event BEFORELAYERUPDATE\r\n         * @param {TC.Layer} layer Capa que va a actualizarse.\r\n         */\r\n        /**\r\n         * Se ha actualizado una capa del mapa: se ha modificado sus entidades o se ha cargado una imagen nueva.\r\n         * @event LAYERUPDATE\r\n         * @param {TC.Layer} layer Capa que se ha actualizado.\r\n         */\r\n        /**\r\n         * Ha habido un error al cargar la capa, bien porque no se ha podido obtener su capabilities o porque no soporta CRS compatibles.\r\n         * @event LAYERERROR\r\n         * @param {TC.Layer} layer Capa que sufre el error.\r\n         */\r\n        /**\r\n         * Se ha establecido una nueva capa como mapa base.\r\n         * @event BASELAYERCHANGE\r\n         * @param {TC.Layer} layer Capa que es el nuevo mapa base.\r\n         */\r\n        /**\r\n         * Se va a actualizar alguna capa del mapa.\r\n         * @event BEFOREUPDATE\r\n         */\r\n\r\n        self.div.classList.add(TC.Consts.classes.LOADING, TC.Consts.classes.MAP);\r\n\r\n        // Para gestionar zoomToMarkers\r\n        self._markerPromises = [];\r\n\r\n        self._layerBuffer = {\r\n            layers: [],\r\n            contains: function (id) {\r\n                return this.layers.some(function (l) {\r\n                    return l.id === id;\r\n                });\r\n            },\r\n            getIndex: function (id) {\r\n                return this.layers.reduce(getReduceByValueFunction('id', id), -1);\r\n            },\r\n            add: function (id, zIndex, isBase) {\r\n                const obj = {\r\n                    id: id,\r\n                    pending: true,\r\n                    zIndex: zIndex,\r\n                    isBase: isBase\r\n                };\r\n                this.layers.splice(this.getIndexForZIndex(zIndex), 0, obj);\r\n            },\r\n            remove: function (id) {\r\n                this.layers.splice(this.getIndex(id), 1);\r\n            },\r\n            getMapLayers: function () {\r\n                return this.layers\r\n                    .filter(l => l.pending === false)\r\n                    .filter(l => !l.rejected)\r\n                    .map(l => l.mapLayer);\r\n            },\r\n            resolve: function (map, layer, isBase) {\r\n                const layerObj = this.layers[this.getIndex(layer.id)];\r\n                layerObj.mapLayer = layer;\r\n                layerObj.pending = false;\r\n                map.layers = this.getMapLayers();\r\n                if (isBase) {\r\n                    if (map.baseLayers.length === 0) {\r\n                        map.baseLayers = new Array(map.options.baseLayers.length);\r\n                    }\r\n\r\n                    var index = map.options.baseLayers.map(function (l) { return l.id }).indexOf(layer.id);\r\n                    if (index < 0) {\r\n                        var index = map.baseLayers.map(function (l) { return l.type }).indexOf(TC.Consts.layerType.VECTOR);\r\n                        if (index < 0) {\r\n                            map.baseLayers.push(layer);\r\n                        } else {\r\n                            map.baseLayers.splice(index, 0, layer);\r\n                        }\r\n                    } else {\r\n                        map.baseLayers.splice(index, 1, layer);\r\n                    }\r\n                }\r\n                else {\r\n                    map.workLayers = map.layers.filter(function (l) {\r\n                        return !l.isBase;\r\n                    });\r\n                }\r\n            },\r\n            reject: function (map, error) {\r\n                const layerObj = this.layers[this.getIndex(error.layerId)];\r\n                layerObj.mapLayer = null;\r\n                layerObj.pending = false;\r\n                layerObj.rejected = true;\r\n                var index = map.options.baseLayers.map(l => l.id).indexOf(error.layerId);\r\n                if (index >= 0) {\r\n                    map.baseLayers.splice(index, 1);\r\n                }\r\n            },\r\n            getResolvedWorkLayerIndex: function (map, id) {\r\n                return this.layers.filter(function (l) {\r\n                    return l.id === id || (!l.isBase && l.pending === false);\r\n                }).reduce(getReduceByValueFunction('id', id), -1);\r\n            },\r\n            getResolvedVisibleLayerIndex: function (map, id) {\r\n                var index = this.getResolvedWorkLayerIndex(map, id);\r\n                if (map.baseLayer) {\r\n                    index = index + 1;\r\n                }\r\n                return index;\r\n            },\r\n            getIndexForZIndex: function (zIndex) {\r\n                return this.layers.reduce(getReduceByZIndexFunction(zIndex), -1) + 1;\r\n            },\r\n            checkMapLoad: function (map) {\r\n                const self = this;\r\n                if (map.options.baseLayers\r\n                    .concat(map.options.workLayers)\r\n                    .every(function (l) {\r\n                        return self.contains(l.id || l);\r\n                    }) && // Si ya se han empezado a procesar todas las capas de las opciones\r\n                    !this.layers.some(function (layer) {\r\n                        return layer.pending === true; // Si ya se han terminado de procesar\r\n                    })) {\r\n                    const throwMapLoad = function () {\r\n                        if (!map.isLoaded) {\r\n                            const setLoaded = function () {\r\n\r\n                                // 07/03/2019 GLS: Bug 24832 la gestin del estado comienza despus de TC.Consts.event.MAPLOAD, \r\n                                // como los callbacks a loaded se lanzan segn el orden de suscripcin, el de script.js de IDENA se lanza antes \r\n                                // que el de la gestin del estado, lo que provoca que las capas aadidas por queryString no se registren.\r\n                                if (map.options.stateful) {\r\n                                    _setupStateControl.call(map);\r\n                                }\r\n\r\n                                map.isLoaded = true;\r\n                                map.div.classList.remove(TC.Consts.classes.LOADING);\r\n                                map.trigger(TC.Consts.event.MAPLOAD);\r\n                            };\r\n                            // tenemos estado 3d\r\n                            if (map.state && map.state.vw3) {\r\n                                if (!map.div.classList.contains(TC.Consts.classes.THREED)) {\r\n                                    map.div.classList.add(TC.Consts.classes.THREED);\r\n\r\n                                    TC.loadJS(\r\n                                        !TC.view || !TC.view.ThreeD,\r\n                                        TC.apiLocation + 'TC/view/ThreeD',\r\n                                        function () {\r\n                                            TC.view.ThreeD.apply({\r\n                                                map: map, state: map.state.vw3, callback: function () {\r\n                                                    setLoaded();\r\n\r\n                                                    map.getControlsByClass(TC.control.ThreeD)[0].button.removeAttribute(\"disabled\");\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    );\r\n                                }\r\n                            } else {\r\n                                setLoaded();\r\n                            }\r\n                        }\r\n                    };\r\n                    // Gestionamos el final de la carga del mapa\r\n                    if (map.baseLayer) {\r\n                        throwMapLoad();\r\n                    }\r\n                    else {\r\n                        //GLS: Si no hay mapa de fondo cargado es posible que se haya aadido desde dilogo modal, lo comprobamos en todos los mapas de fondo disponibles del API\r\n                        var onAvailables = [];\r\n                        if (map.state && map.state.base) {\r\n                            onAvailables = TC.Cfg.availableBaseLayers.filter(function (l) { return l.id === map.state.base });\r\n                        }\r\n\r\n                        if (onAvailables.length > 0) {\r\n                            onAvailables[0].isBase = true;\r\n                            map.addLayer(onAvailables[0]).then(function (layer) {\r\n                                throwMapLoad();\r\n                            });\r\n                        }\r\n                        else {\r\n                            // Si no hay capa base cargada cargamos la primera compatible\r\n                            const lastResortBaseLayer = map.baseLayers.filter(function (layer) {\r\n                                return !layer.mustReproject;\r\n                            }).filter(function (l) {\r\n                                return l.wrap && l.wrap.layer;\r\n                            });\r\n\r\n                            if (lastResortBaseLayer.length > 0) {\r\n                                map.wrap.setBaseLayer(lastResortBaseLayer[0].wrap.layer);\r\n                                map.baseLayer = lastResortBaseLayer[0];\r\n                            }\r\n\r\n                            throwMapLoad();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        self._layerBuffer.layers = [];\r\n\r\n        if (!TC.ready) {\r\n            TC.Cfg = TC.Util.extend({}, TC.Defaults, TC.Cfg);\r\n            TC.ready = true;\r\n        }\r\n\r\n        // GLS: mergeOptions es inclusivo, para poder sobrescribir los tipos de bsqueda, aado con valor a false las que el usuario no haya configurado.\r\n        if (options && options.controls && options.controls.search && options.controls.search.allowedSearchTypes) {\r\n            for (var allowed in TC.Cfg.controls.search.allowedSearchTypes) {\r\n                if (!options.controls.search.allowedSearchTypes.hasOwnProperty(allowed)) {\r\n                    options.controls.search.allowedSearchTypes[allowed] = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Aado las capas disponibles a la configuracin general\r\n\r\n        /**\r\n         * Objeto de opciones del constructor.\r\n         * @property options\r\n         * @type object\r\n         */\r\n        options = options || {};\r\n        mergeOptions.call(self, options);\r\n\r\n        var init = async function () {\r\n\r\n            self.state = await self.checkLocation();\r\n\r\n            if (self.options.layout) {\r\n                self.trigger(TC.Consts.event.LAYOUTLOAD, { map: self });\r\n            }\r\n\r\n            if (options && options.workLayers !== undefined) {\r\n                self.options.workLayers = options.workLayers;\r\n            }\r\n            if (options && options.baseLayers !== undefined) {\r\n                self.options.baseLayers = options.baseLayers;\r\n            }\r\n\r\n            if (self.options.zoomToFeatures) {\r\n                // zoom a features solo cuando se cargue el mapa\r\n                var handleFeaturesAdd = function handleFeaturesAdd(e) {\r\n                    clearTimeout(self._zoomToFeaturesTimeout);\r\n\r\n                    self._zoomToFeaturesTimeout = setTimeout(function () {\r\n                        self.zoomToFeatures(e.layer.features, { animate: false });\r\n                        self.off(TC.Consts.event.FEATURESADD, handleFeaturesAdd);\r\n                    }, 100);\r\n                };\r\n                self.on(TC.Consts.event.FEATURESADD, handleFeaturesAdd);\r\n            }\r\n            var _handleLayerAdd = function _handleLayerAdd(e) {\r\n                if (e.layer.isBase && (e.layer === self.baseLayer || (self.baseLayer && e.layer.fallbackLayer && e.layer.fallbackLayer.id === self.baseLayer.id))) {\r\n                    if (typeof self.state !== \"undefined\") {\r\n                        if (self.state.crs) {\r\n                            self.loaded(function () {\r\n                                self.setProjection({\r\n                                    crs: self.state.crs,\r\n                                    extent: self.state.ext\r\n                                });\r\n                            });\r\n                        }\r\n                        else {\r\n                            self.setExtent(self.state.ext, { animate: false });\r\n                        }\r\n                    }\r\n                    self.off(TC.Consts.event.LAYERADD, _handleLayerAdd);\r\n                }\r\n            };\r\n            self.on(TC.Consts.event.LAYERADD, _handleLayerAdd);\r\n\r\n            /**\r\n             * Well-known ID (WKID) del CRS del mapa.\r\n             * @property crs\r\n             * @type string\r\n             */\r\n            self.crs = self.options.crs;\r\n            self.initialExtent = self.options.initialExtent;\r\n            self.maxExtent = self.options.maxExtent;\r\n            self.defaultInfoContainer = self.defaultInfoContainer || self.options.defaultInfoContainer;\r\n\r\n            self.wrap = new TC.wrap.Map(self);\r\n\r\n            TC.loadJS(\r\n                !window[TC.Consts.PROJ4JSOBJ],\r\n                [\r\n                    TC.url.proj4js\r\n                ],\r\n                function () {\r\n                    TC.loadJSInOrder(\r\n                        !window[TC.Consts.OLNS],\r\n                        [\r\n                            TC.url.ol,\r\n                            TC.url.olConnector\r\n                        ],\r\n                        function () {\r\n                            TC.loadProjDef({\r\n                                crs: self.options.crs,\r\n                                callback: function () {\r\n                                    self.wrap.setMap();\r\n                                    const ctlPromises = [];\r\n\r\n                                    for (var name in self.options.controls) {\r\n                                        var ctlOptions = self.options.controls[name];\r\n                                        if (ctlOptions) {\r\n                                            ctlOptions = typeof ctlOptions === 'boolean' ? {} : TC.Util.extend(true, {}, ctlOptions);\r\n                                            if (typeof ctlOptions.div === 'string') {\r\n                                                ctlOptions.div = self.div.querySelector('#' + ctlOptions.div) || ctlOptions.div;\r\n                                            }\r\n                                            ctlPromises.push(self.addControl(name, ctlOptions));\r\n                                        }\r\n                                    }\r\n\r\n                                    self.on(TC.Consts.event.BEFORELAYERUPDATE, _triggerLayersBeforeUpdateEvent);\r\n                                    self.on(TC.Consts.event.LAYERUPDATE, _triggerLayersUpdateEvent);\r\n                                    self.on(TC.Consts.event.LAYERERROR, _triggerLayersUpdateEvent);\r\n\r\n                                    var i;\r\n                                    var lyrCfg;\r\n                                    for (i = 0; i < self.options.baseLayers.length; i++) {\r\n                                        lyrCfg = self.options.baseLayers[i];\r\n                                        if (typeof lyrCfg === 'string') {\r\n                                            lyrCfg = getAvailableBaseLayer.call(self, lyrCfg);\r\n                                        }\r\n                                        self.addLayer(TC.Util.extend({}, lyrCfg, { isBase: true, map: self }));\r\n                                    }\r\n\r\n                                    var setVisibility = function (layer) {\r\n                                        if (layer.isRaster() && !layer.names) {\r\n                                            layer.setVisibility(false);\r\n                                        }\r\n                                    };\r\n                                    const workLayersNotInState = self.options.workLayers\r\n                                        .map(function (workLayer) {\r\n                                            return TC.Util.extend({}, workLayer, { map: self });\r\n                                        })\r\n                                        .filter(function (workLayer) {\r\n                                            if (!self.state || !self.state.layers) {\r\n                                                return true;\r\n                                            }\r\n                                            return !self.state.layers.some(function (stateLayer) {\r\n                                                const result = stateLayer.u === workLayer.url && workLayer.layerNames.indexOf(stateLayer.n) >= 0;\r\n                                                if (result) {\r\n                                                    stateLayer.id = workLayer.id; // Hemos identificado la capa, le damos el id que le corresponde\r\n                                                }\r\n                                                return result;\r\n                                            });\r\n                                        });\r\n                                    workLayersNotInState.forEach(function (workLayer) {\r\n                                        self.addLayer(workLayer).then(setVisibility);\r\n                                    });\r\n\r\n                                    if (self.state && self.state.layers) {\r\n\r\n                                        self.state.layers.forEach(function (stateLayer) {\r\n\r\n                                            // aado como promesa cada una de las capas que se aaden\r\n                                            self.addLayer({\r\n                                                id: stateLayer.id || TC.getUID(),\r\n                                                url: TC.Util.isOnCapabilities(stateLayer.u, stateLayer.u.indexOf(window.location.protocol) < 0) || stateLayer.u,\r\n                                                hideTitle: stateLayer.h,\r\n                                                layerNames: stateLayer.n ? stateLayer.n.split(',') : \"\",\r\n                                                unremovable: stateLayer.ur,\r\n                                                title: stateLayer.t,\r\n                                                filter: stateLayer.f,\r\n                                                renderOptions: {\r\n                                                    opacity: stateLayer.o,\r\n                                                    hide: !stateLayer.v\r\n                                                }\r\n                                            }).then(function (layer) {\r\n                                                var rootNode = layer.wrap.getRootLayerNode();\r\n                                                layer.title = stateLayer.t || rootNode.Title || rootNode.title;\r\n                                                if (this.o < 1) {\r\n                                                    layer.setOpacity(this.o);\r\n                                                }\r\n                                                if (!this.v) {\r\n                                                    layer.setVisibility(this.v);\r\n                                                }\r\n                                            }.bind(stateLayer))\r\n                                                .catch(function (error) {\r\n                                                    // no hacemos nada porque al llegar a este punto ya hemos gestionado el error en la instruccin crsLayerError(self, lyr); en la lnea 4888\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\r\n                                                    //URI:Si que hacemos ya que si falla el getCapabilities no hay CRS que valga\r\n                                                    self.toast(error.message, { type: TC.Consts.msgType.ERROR });\r\n                                                });\r\n                                        });\r\n                                    }\r\n                                    Promise.all(ctlPromises).finally(function () {\r\n                                        // 13/03/2020 si el mapa mantiene estado y tenemos estado de controles, pasamos a establecer los estados\r\n                                        if (self.state && self.state.ctl) {\r\n                                            self.importControlStates(self.state.ctl);\r\n                                        }\r\n\r\n                                        self.isReady = true;\r\n                                        self.trigger(TC.Consts.event.MAPREADY);\r\n                                    })\r\n                                    setHeightFix(self.div);\r\n                                }\r\n                            });\r\n                        }\r\n                    );\r\n                }\r\n            );\r\n\r\n            self.on(TC.Consts.event.FEATURECLICK, function (e) {\r\n                if (!self.activeControl || !self.activeControl.isExclusive()) {\r\n                    e.feature.showInfo();\r\n                }\r\n            });\r\n\r\n            self.on(TC.Consts.event.NOFEATURECLICK, function (e) {\r\n                e.layer._noFeatureClicked = true;\r\n                var allLayersClicked = true;\r\n                for (var i = 0, len = self.workLayers.length; i < len; i++) {\r\n                    if (!self.workLayers[i]._noFeatureClicked) {\r\n                        allLayersClicked = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (allLayersClicked) {\r\n                    self.workLayers.forEach(function (wl) {\r\n                        delete wl._noFeatureClicked;\r\n                    });\r\n                    self.getControlsByClass(TC.control.Popup).forEach(function (p) {\r\n                        if (p.isVisible()) {\r\n                            p.hide();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        };\r\n\r\n        mapProto.getMapState = async function (options) {\r\n            const self = this;\r\n\r\n            var state = await _getMapState.call(self, options);\r\n            return TC.Util.utf8ToBase64(state);\r\n        };\r\n\r\n        mapProto.getPreviousMapState = function () {\r\n            return previousState;\r\n        };\r\n\r\n        mapProto.checkLocation = async function () {\r\n            const self = this;\r\n            var hash = window.location.hash;\r\n\r\n            if (hash && hash.length > 1) {\r\n                hash = hash.substr(1);\r\n\r\n                var obj;\r\n                try {\r\n                    obj = await jsonpackProcess('unpack', TC.Util.base64ToUtf8(hash));\r\n                }\r\n                catch (error) {\r\n                    try {\r\n                        obj = JSON.parse(TC.Util.base64ToUtf8(hash));\r\n                    }\r\n                    catch (err) {\r\n                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                if (TC.Util.detectIE() && window.location.href.length === 2047) {\r\n                    TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValidForEdge'), TC.Consts.msgErrorMode.TOAST);\r\n                }\r\n\r\n                if (obj) {\r\n                    var inValidState = false;\r\n                    //chequeo la integriadad del objeto restaurado del State\r\n                    if (!obj.hasOwnProperty(\"ext\")) {\r\n                        inValidState = true;\r\n                        obj.ext = self.options.initialExtent;\r\n                    }\r\n                    if (!obj.hasOwnProperty(\"base\")) {\r\n                        inValidState = true;\r\n                        obj.base = self.options.defaultBaseLayer;\r\n                    }\r\n                    if (!obj.hasOwnProperty(\"layers\")) {\r\n                        inValidState = true;\r\n                        obj.layers = [];\r\n                    }\r\n                    else {\r\n                        for (var i = obj.layers.length - 1; i >= 0; i--) {\r\n                            if (!obj.layers[i] || !obj.layers[i].hasOwnProperty(\"u\") || !obj.layers[i].hasOwnProperty(\"n\")) {\r\n                                inValidState = true;\r\n                                obj.layers.length = obj.layers.length - 1;\r\n                                continue;\r\n                            }\r\n                            else if (!obj.layers[i].hasOwnProperty(\"o\") || !obj.layers[i].hasOwnProperty(\"v\") || !obj.layers[i].hasOwnProperty(\"h\")) {\r\n                                inValidState = true\r\n                                TC.Util.extend(obj.layers[i], {\r\n                                    o: (obj.layers[i].o || 1),\r\n                                    v: (obj.layers[i].v || true),\r\n                                    h: (obj.layers[i].h || false)\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (obj.hasOwnProperty(\"vw3\")) {\r\n\r\n                        if (!obj.vw3) {\r\n                            inValidState = true;\r\n                        } else if (!obj.vw3.cp || (obj.vw3.cp && obj.vw3.cp.length != 3) ||\r\n                            !obj.vw3.chpr || (obj.vw3.chpr && obj.vw3.chpr.length != 3) ||\r\n                            !obj.vw3.bcpd) {\r\n                            inValidState = true;\r\n                        }\r\n                    }\r\n\r\n                    if (inValidState)\r\n                        TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);\r\n                    return obj;\r\n                }\r\n                TC.error(TC.Util.getLocaleString(self.options.locale, 'mapStateNotValid'), TC.Consts.msgErrorMode.TOAST);\r\n            }\r\n            return;\r\n        };\r\n\r\n        /*\r\n        *  _triggerLayersBeforeUpdateEvent: Triggers map beforeupdate event (jQuery.Event) when any layer starts loading\r\n        *  Parameters: OpenLayers.Layer, event name ('loadstart', 'loadend')\r\n        */\r\n        var _triggerLayersBeforeUpdateEvent = function (e) {\r\n            if (loadingLayerCount <= 0) {\r\n                loadingLayerCount = 0;\r\n                self.trigger(TC.Consts.event.BEFOREUPDATE);\r\n            }\r\n            loadingLayerCount = loadingLayerCount + 1;\r\n        };\r\n\r\n        var _triggerLayersUpdateEvent = function (e) {\r\n            loadingLayerCount = loadingLayerCount - 1;\r\n            if (loadingLayerCount <= 0) {\r\n                loadingLayerCount = 0;\r\n                self.trigger(TC.Consts.event.UPDATE);\r\n            }\r\n        };\r\n\r\n        TC.i18n = TC.i18n || {};\r\n        // i18n: carga de recursos si no est cargados previamente\r\n        TC.i18n.loadResources = TC.i18n.loadResources || function (condition, path, locale) {\r\n            var result;\r\n            if (condition) {\r\n                result = new Promise(function (resolve, reject) {\r\n                    TC.ajax({\r\n                        url: path + locale + '.json',\r\n                        method: 'GET',\r\n                        responseType: TC.Consts.mimeType.JSON\r\n                    })\r\n                        .then(function (response) {\r\n                            const data = response.data;\r\n                            TC.i18n[locale] = TC.i18n[locale] || {};\r\n                            TC.Util.extend(TC.i18n[locale], data);\r\n                            TC.i18n.currentLocale = TC.i18n[locale];\r\n                            TC.i18n.currentLocaleKey=locale\r\n                            resolve();\r\n                        })\r\n                        .catch(function (err) {\r\n                            reject(err);\r\n                        });\r\n                });\r\n            } else {\r\n                TC.i18n.currentLocale = TC.i18n[locale];\r\n                result = Promise.resolve();\r\n            }\r\n            return result;\r\n        };\r\n\r\n        const locale = self.options.locale;\r\n\r\n        TC.i18n.loadResources(!TC.i18n[locale], TC.apiLocation + 'TC/resources/', locale).finally(function () {\r\n            // Si no hay tamao definido en el div, lo ponemos a pantalla completa\r\n            // Lo ponemos aqu porque es poco antes de cargar markup.html\r\n            const divRect = self.div.getBoundingClientRect();\r\n            if (divRect.height === 0) {\r\n                document.querySelectorAll('html,body').forEach(elm => elm.classList.add('tc-fullscreen'));\r\n                self.div.classList.add('tc-fullscreen');\r\n            }\r\n            // 22/03/2019 GLS: siempre vamos a tener layout porque en sitna.js (1757) se establece por defecto layout/responsive\r\n            //                 si el usuario define otro se sobrescribe\r\n            if (self.options.layout) {\r\n                var layout = self.options.layout;\r\n\r\n                self.trigger(TC.Consts.event.BEFORELAYOUTLOAD, { map: self });\r\n\r\n                var layoutURLs = {};\r\n                var ignoreError = false;\r\n                if (typeof layout === 'string') {\r\n                    var href = layout.trim();\r\n                    href += href.match(/\\/$/) ? '' : '/';\r\n\r\n                    layoutURLs.config = href + 'config.json';\r\n                    layoutURLs.markup = href + 'markup.html';\r\n                    layoutURLs.style = href + 'style.css';\r\n                    layoutURLs.script = href + 'script.js';\r\n                    layoutURLs.i18n = href + 'resources';\r\n\r\n                    // Si el layout se define como string, no podemos saber qu archivos a definido y cuales no, \r\n                    // por eso tampoco podemos saber si es un error de configuracin o es que no lo ha definido as que no mostramos error entendiendo que si\r\n                    // el archivo no est es porque no quiere.\r\n                    ignoreError = true;\r\n                }\r\n                else if (\r\n                    layout.hasOwnProperty('config') ||\r\n                    layout.hasOwnProperty('markup') ||\r\n                    layout.hasOwnProperty('style') ||\r\n                    layout.hasOwnProperty('script') ||\r\n                    layout.hasOwnProperty('href') ||\r\n                    layout.hasOwnProperty('i18n')\r\n                ) {\r\n                    layoutURLs = TC.Util.extend({}, layout);\r\n                }\r\n\r\n                if (layoutURLs.i18n) {\r\n                    layoutURLs.i18n += layoutURLs.i18n.match(/\\/$/) ? '' : '/';\r\n                }\r\n\r\n                self.layout = layoutURLs;\r\n\r\n                const layoutPromises = [];\r\n                const ResponseError = function (status, url) {\r\n                    this.status = status;\r\n                    this.url = url;\r\n                };\r\n                const onError = function (error) {\r\n                    if (!ignoreError || error.status != 404) {\r\n                        const mapObj = TC.Map.get(document.querySelector('.' + TC.Consts.classes.MAP));\r\n                        TC.error(\r\n                            TC.Util.getLocaleString(mapObj.options.locale, \"urlFailedToLoad\",\r\n                                { url: error.url }),\r\n                            [TC.Consts.msgErrorMode.TOAST, TC.Consts.msgErrorMode.EMAIL],\r\n                            \"Error al cargar \" + error.url);\r\n                    }\r\n                };\r\n\r\n                const i18nLayoutPromise = new Promise(function (resolve, reject) {\r\n                    if (layoutURLs.config) {\r\n\r\n                        layoutPromises.push(fetch(layoutURLs.config)\r\n                            .then(function (response) {\r\n                                if (!response.ok) { // status no est en el rango 200-299\r\n                                    throw new ResponseError(response.status, layoutURLs.config);\r\n                                }\r\n                                return response.json();\r\n                            }).then(function (data) {\r\n                                resolve(data.i18n);\r\n                                mergeOptions.call(self, data, options);\r\n                            }).catch(function (error) {\r\n                                if (error.status) {\r\n                                    onError(error);\r\n                                }\r\n\r\n                                resolve(false);\r\n                            }));\r\n                    }\r\n                    else {\r\n                        resolve(false);\r\n                    }\r\n                });\r\n                layoutPromises.push(i18nLayoutPromise);\r\n\r\n                if (layoutURLs.style) {\r\n                    layoutPromises.push(new Promise(function (resolve, reject) {\r\n                        // Aadimos una clase para hacer ms fciles las reglas del layout\r\n                        self.div.classList.add('tc-lo');\r\n\r\n                        // GLS: 28/03/2019 Necesito hacer el HEAD para validar si existe porque si lo hago directamente y lo cargo como BLOB, \r\n                        // las referencias a las fuentes son relativas al blob por lo que no funcionan, as que HEAD y si existe lo cargo por href\r\n                        fetch(layoutURLs.style, {\r\n                            method: navigator.onLine ? 'HEAD' : 'GET' // FLP: Las peticiones HEAD no se guardan en la cache, as que offline fallan, por eso la opcin GET.\r\n                        }).then(function (response) {\r\n                            if (!response.ok) { // status no est en el rango 200-299\r\n                                throw new ResponseError(response.status, layoutURLs.style);\r\n                            }\r\n                            return response;\r\n                        }).then(function () {\r\n                            var linkElement = document.createElement('link');\r\n                            linkElement.rel = 'stylesheet';\r\n                            linkElement.href = layoutURLs.style;\r\n\r\n                            document.head.appendChild(linkElement);\r\n                            resolve();\r\n                        }).catch(function (error) {\r\n                            if (error.status) {\r\n                                onError(error);\r\n                            }\r\n\r\n                            resolve();\r\n                        });\r\n                    }));\r\n                }\r\n\r\n                if (layoutURLs.markup) {\r\n                    layoutPromises.push(new Promise(function (resolve, reject) {\r\n\r\n                        fetch(layoutURLs.markup)\r\n                            .then(function (response) {\r\n                                if (!response.ok) { // status no est en el rango 200-299\r\n                                    throw new ResponseError(response.status, layoutURLs.markup);\r\n                                }\r\n                                return response.text();\r\n                            }).then(function (data) {\r\n                                // markup.html puede ser una plantilla para soportar i18n, compilarla si es el caso\r\n                                i18nLayoutPromise.then(function (i18n) {\r\n                                    if (i18n && locale && layoutURLs.i18n) {\r\n                                        TC.i18n.loadResources(true, layoutURLs.i18n, locale).finally(function () {\r\n                                            const replacerFn = function (match, grp1, grp2, grp3) {\r\n                                                return TC.Util.getLocaleString(locale, grp1 || grp2 || grp3);\r\n                                            };\r\n                                            //data = data.replace(/\\{\\{([^\\}\\{]+)\\}\\}/g, replacerFn); // Estilo {{key}}\r\n                                            //data = data.replace(/\\{@i18n \\$key=\"([^\\}\\{]+)\"\\/\\}/g, replacerFn); // Estilo {@i18n $key=\"key\"/}\r\n                                            //data = data.replace(/\\{\\{i18n \"([^\\}\\{]+)\"\\}\\}/g, replacerFn); // Estilo {{i18n \"key\"}}\r\n                                            data = data.replace(/\\{\\{i18n \"([^\\}\\{]+)\"\\}\\}|\\{\\{([^\\}\\{]+)\\}\\}|\\{@i18n \\$key=\"([^\\}\\{]+)\"\\/\\}/g, replacerFn); // Los tres estilos anteriores\r\n                                            self.div.insertAdjacentHTML('beforeend', data);\r\n                                            resolve();\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        self.div.insertAdjacentHTML('beforeend', data);\r\n                                        resolve();\r\n                                    }\r\n                                });\r\n                            }).catch(function (error) {\r\n                                if (error.status) {\r\n                                    onError(error);\r\n                                }\r\n\r\n                                resolve();\r\n                            });\r\n                    }));\r\n                }\r\n\r\n                Promise.all(layoutPromises).finally(function () {\r\n\r\n                    if (layoutURLs.script) {\r\n                        fetch(layoutURLs.script)\r\n                            .then(function (response) {\r\n                                if (!response.ok) { // status no est en el rango 200-299\r\n                                    throw new ResponseError(response.status, layoutURLs.script);\r\n                                }\r\n                                return response.blob();\r\n                            }).then(function (fileBlob) {\r\n                                var fileURL = URL.createObjectURL(fileBlob);\r\n\r\n                                var scriptElement = document.createElement('script');\r\n                                scriptElement.src = fileURL;\r\n\r\n                                scriptElement.onload = function () {\r\n                                    setHeightFix(self.div);\r\n                                    init();\r\n                                };\r\n\r\n                                document.head.appendChild(scriptElement);\r\n\r\n                            }).catch(function (error) {\r\n                                if (error.status) {\r\n                                    onError(error);\r\n                                }\r\n                                init();\r\n                            });\r\n                    } else {\r\n                        init();\r\n                    }\r\n                });\r\n\r\n            }\r\n            else {\r\n                init();\r\n            }\r\n        });\r\n\r\n        // Borramos rboles de capas cacheados\r\n        self.on(TC.Consts.event.UPDATEPARAMS, function (e) {\r\n            deleteTreeCache(e.layer);\r\n        });\r\n        self.on(TC.Consts.event.ZOOM, function () {\r\n            for (var i = 0; i < self.workLayers.length; i++) {\r\n                deleteTreeCache(self.workLayers[i]);\r\n            }\r\n        });\r\n\r\n        // Redefinimos TC.error para aadir un aviso en el mapa\r\n        /*var oldError = TC.error;\r\n        TC.error = function (text) {\r\n            oldError(text);\r\n            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });\r\n        };*/\r\n        var oldError = TC.error;\r\n        TC.error = function (text, options, subject) {\r\n            if (TC.isDebug && console.trace) {\r\n                console.trace();\r\n            }\r\n            if (!options) {\r\n                oldError(text);\r\n                self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });\r\n            }\r\n            else {\r\n                var fnc = function (text, mode, subject) {\r\n                    switch (mode) {\r\n                        case TC.Consts.msgErrorMode.TOAST:\r\n                            if (!self.toast) { console.warn(\"No existe el objeto Toast\"); return; }\r\n                            self.toast(text, { type: TC.Consts.msgType.ERROR, duration: TC.Cfg.toastDuration * 2 });\r\n                            break;\r\n                        case TC.Consts.msgErrorMode.EMAIL:\r\n                            if (TC.Cfg.loggingErrorsEnabled) {\r\n                                JL(\"onerrorLogger\").fatalException(!subject ? text : {\r\n                                    \"msg\": subject,\r\n                                    \"errorMsg\": text,\r\n                                }, null);\r\n                            }\r\n                            break;\r\n                        case TC.Consts.msgErrorMode.CONSOLE:\r\n                        default:\r\n                            console.error(text)\r\n                            break;\r\n                    }\r\n                }\r\n                if (!Array.isArray(options)) {\r\n                    fnc(text, options, subject)\r\n                }\r\n                else {\r\n                    for (var i = 0; i < options.length; i++)\r\n                        fnc(text, options[i], subject)\r\n                }\r\n            }\r\n\r\n        };\r\n    };\r\n\r\n    TC.Map._instances = [];\r\n\r\n    TC.Map.get = function (elm) {\r\n        for (var i = 0, len = TC.Map._instances.length; i < len; i++) {\r\n            const instance = TC.Map._instances[i];\r\n            if (instance.div === elm) {\r\n                return instance;\r\n            }\r\n        }\r\n    };\r\n\r\n    TC.inherit(TC.Map, TC.EventTarget);\r\n\r\n    var deleteTreeCache = function (layer) {\r\n        if (layer.type === TC.Consts.layerType.WMS) {\r\n            layer.tree = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Funcin que mezcla opciones de mapa relativos a capa, teniendo cuidado de que puede haber objetos de opciones de capa o identificadores de capa.\r\n     * En este ltimo caso, si no son la opcin prioritaria, hay que sustituirlos por los objetos de definiciones de capa.\r\n     */\r\n    var mergeLayerOptions = function (optionsArray, propertyName) {\r\n        // lista de opciones de capa de los argumentos\r\n        var layerOptions = Array.prototype.slice.call(optionsArray).map(function (elm) {\r\n            var result = {};\r\n            if (elm) {\r\n                result[propertyName] = elm[propertyName];\r\n            }\r\n            return result;\r\n        });\r\n        if (propertyName === 'availableBaseLayers') console.log(\"layerOptions\", layerOptions);\r\n        // aadimos las opciones de capa de la configuracin general\r\n        var layerOption = {};\r\n        layerOption[propertyName] = TC.Cfg[propertyName];\r\n        layerOptions.unshift(layerOption);\r\n\r\n        //Si se han definido baseLayers en el visor, hay que hacer un merge con las predefinidas en la API\r\n        if (propertyName === 'baseLayers' && layerOptions[1]['baseLayers']) {\r\n            layerOption = layerOptions[1];\r\n\r\n            for (var i = 0; i < layerOption['baseLayers'].length; i++) {\r\n                if (typeof layerOption['baseLayers'][i] === 'object') {\r\n                    TC.Util.extend(layerOption['baseLayers'][i], getAvailableBaseLayer.call(this, layerOption['baseLayers'][i].id));\r\n                }\r\n            }\r\n        } else {\r\n            layerOptions.unshift(true); // Deep merge\r\n            layerOption = TC.Util.extend.apply(this, layerOptions);\r\n            if (propertyName === 'availableBaseLayers') console.log(\"layerOption\", layerOption);\r\n        }\r\n\r\n        return layerOption[propertyName];\r\n    };\r\n\r\n    const mergeControlOptions = function (controlOptions) {\r\n\r\n        if (controlOptions.controlContainer) {\r\n\r\n            if (Array.isArray(controlOptions.controlContainer.controls)) {\r\n\r\n                controlOptions.controlContainer.controls.forEach((ctl) => {\r\n                    Object.keys(ctl).filter((key) => key !== \"position\").forEach((name) => {\r\n                        if (controlOptions[name] !== undefined) {\r\n                            if (typeof ctl[name] === 'boolean') {\r\n                                ctl[name] = {};\r\n                            }\r\n                            TC.Util.extend(ctl[name], controlOptions[name]);\r\n                            delete controlOptions[name];\r\n                        }\r\n                    });\r\n                });\r\n\r\n            } else {\r\n                // GLS compatibilidad hacia atrs\r\n\r\n                Object.keys(controlOptions).filter(function (key) {\r\n                    return Object.keys(controlOptions.controlContainer.controls).indexOf(key) > -1\r\n                }).forEach(function (key) {\r\n                    const containerControl = controlOptions.controlContainer.controls[key];\r\n                    if (typeof containerControl.options === 'boolean') {\r\n                        containerControl.options = {}\r\n                    }\r\n                    TC.Util.extend(containerControl.options, controlOptions[key]);\r\n                    delete controlOptions[key];\r\n                });\r\n            }\r\n        }\r\n\r\n        return controlOptions;\r\n    }\r\n\r\n    const mergeOptions = function () {\r\n        const argArray = [true, {}, TC.Cfg].concat(Array.prototype.slice.call(arguments));\r\n        const result = this.options = TC.Util.extend.apply(this, argArray);\r\n        // Concatenamos las colecciones availableBaseLayers\r\n        result.availableBaseLayers = TC.Cfg.availableBaseLayers.concat.apply(TC.Cfg.availableBaseLayers, Array.prototype.map.call(arguments, function (arg) {\r\n            return arg.availableBaseLayers || [];\r\n        }));\r\n        result.baseLayers = mergeLayerOptions.call(this, arguments, 'baseLayers');\r\n        result.workLayers = mergeLayerOptions.call(this, arguments, 'workLayers');\r\n\r\n        const controls = Array.prototype.slice.call(arguments)\r\n            .filter(elem => elem.controls)\r\n            .map(elem => elem.controls);\r\n        if (controls.length > 0) {\r\n            result.controls = TC.Util.extend(true, result.controls, mergeControlOptions(TC.Util.extend(true, controls[0], controls[1])));\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var mapProto = TC.Map.prototype;\r\n\r\n    var crsLayerError = function (map, layer) {\r\n        var errorMessage = 'Layer \"' + layer.title + '\" (\"' + layer.names + '\"): ';\r\n        var reason;\r\n        if (layer.isValidFromNames()) {\r\n            reason = 'layerSrsNotCompatible'\r\n        } else {\r\n            reason = 'layerNameNotValid';\r\n        }\r\n        errorMessage += TC.Util.getLocaleString(map.options.locale, reason);\r\n        TC.error(errorMessage);\r\n        map.trigger(TC.Consts.event.LAYERERROR, { layer: layer, reason: reason });\r\n\r\n        const error = Error(errorMessage);\r\n        error.layerId = layer.id;\r\n        return error;\r\n    };\r\n\r\n    mapProto.getCRS = function () {\r\n        const self = this;\r\n\r\n        if (!self.on3DView) {\r\n            return self.crs;\r\n        } else {\r\n            return self.view3D.crs;\r\n        }\r\n    };\r\n\r\n    const appendRasterEvents = function (layer) {\r\n        layer.wrap.$events.on(TC.Consts.event.TILELOADERROR, function (event) {            \r\n            if ((event.error.code && event.error.code.toString() != '404') && (event.error.text != 'offline')) {\r\n                const wrap = this;\r\n                if (!wrap._tileloaderror) {\r\n                    const path = layer.getPath();\r\n                    const title = path.length ? path[path.length - 1] : layer.title;\r\n                    layer.map.toast(TC.Util.getLocaleString(layer.map.options.locale, 'tileload.error',\r\n                        { name: title, error: event.error.text }),\r\n                        { type: TC.Consts.msgType.ERROR });\r\n                    wrap._tileloaderror = true;\r\n                    const onTileload = function (e) {\r\n                        if (e.tile.src && e.tile.src !== TC.Consts.BLANK_IMAGE) {\r\n                            delete wrap._tileloaderror;\r\n                            wrap.$events.off(TC.Consts.event.TILELOAD, onTileload);\r\n                        }\r\n                    };\r\n                    wrap.$events.on(TC.Consts.event.TILELOAD, onTileload);\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Aade una capa al mapa.\r\n     * @method addLayer\r\n     * @async\r\n     * @param {TC.Layer|TC.cfg.LayerOptions|string} layer Objeto de capa, objeto de opciones del constructor de la capa, o identificador de capa.\r\n     * @param {function} [callback] Funcin de callback.\r\n     * @return {Promise} Promesa de objeto {{#crossLink \"TC.Layer\"}}{{/crossLink}}\r\n     */\r\n    mapProto.addLayer = function (layer, callback) {\r\n        const self = this;\r\n\r\n        const result = new Promise(function (resolve, reject) {\r\n\r\n            if (typeof layer === 'object' && !layer.id) {\r\n                layer.id = TC.getUID();\r\n            }\r\n\r\n            let zIndex = layer.options ? layer.options.zIndex : layer.zIndex;\r\n            if (typeof zIndex !== 'number') {\r\n                zIndex = layer.stealth ? 1 : 0;\r\n            }\r\n\r\n            self._layerBuffer.add(layer.id || layer, zIndex, layer.isBase);\r\n\r\n            if (self.getLayer(layer.id)) {\r\n                // Si ya existe capa con el mismo id, lanzamos error\r\n                const error = Error(`Layer \"${layer.id}\" already exists`);\r\n                error.layerId = layer.id;\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            var lyr;\r\n            var test;\r\n            var objUrl;\r\n\r\n            if (isRaster(layer)) {\r\n                test = !TC.layer || !TC.layer.Raster;\r\n                objUrl = TC.apiLocation + 'TC/layer/Raster';\r\n            }\r\n            else {\r\n                test = !TC.layer || !TC.layer.Vector;\r\n                objUrl = TC.apiLocation + 'TC/layer/Vector';\r\n            }\r\n            TC.loadJS(\r\n                test,\r\n                [objUrl],\r\n                function () {\r\n                    if (typeof layer === 'string') {\r\n                        lyr = new TC.layer.Raster(TC.Util.extend({}, getAvailableBaseLayer.call(self, layer), { map: self }));\r\n                    }\r\n                    else {\r\n                        if (layer instanceof TC.Layer) {\r\n                            lyr = layer;\r\n                            lyr.map = self;\r\n                        }\r\n                        else {\r\n                            layer.map = self;\r\n                            if (layer.type === TC.Consts.layerType.VECTOR || layer.type === TC.Consts.layerType.KML || layer.type === TC.Consts.layerType.WFS) {\r\n                                lyr = new TC.layer.Vector(layer);\r\n                            }\r\n                            else {\r\n                                lyr = new TC.layer.Raster(layer);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    Promise.all([self.wrap.getMap(), lyr.wrap.getLayer()]).then(function () {\r\n\r\n                        self.trigger(TC.Consts.event.BEFORELAYERADD, { layer: lyr });\r\n\r\n                        // Nos aseguramos de que las capas raster se quedan por debajo de las vectoriales\r\n                        var idx;\r\n                        if (isRaster(lyr)) {\r\n                            appendRasterEvents(lyr);\r\n                            idx = self.wrap.indexOfFirstVector();\r\n                        }\r\n                        if (idx === -1) {\r\n                            idx = self.wrap.getLayerCount();\r\n                        }\r\n\r\n                        const currentCrs = self.state && self.state.crs ? self.state.crs : self.getCRS();\r\n                        TC.loadProjDef({\r\n                            crs: currentCrs,\r\n                            callback: function () {\r\n                                const isCompatible = lyr.isCompatible(currentCrs);\r\n                                if (lyr.isBase) {\r\n                                    const baseLayerEndFn = function () {\r\n                                        if (self.state) {\r\n                                            lyr.isDefault = (self.state.base === lyr.id) || (self.state.base === lyr.options.fallbackLayer);\r\n                                        }\r\n                                        else if (typeof self.options.defaultBaseLayer === 'string') {\r\n                                            lyr.isDefault = self.options.defaultBaseLayer === lyr.id;\r\n                                        }\r\n                                        else if (typeof self.options.defaultBaseLayer === 'number') {\r\n                                            lyr.isDefault = self.options.defaultBaseLayer === self.baseLayers.length;\r\n                                        }\r\n                                        if (lyr.isDefault) {\r\n                                            var fit;\r\n                                            if (lyr.mustReproject && !lyr.type === TC.Consts.layerType.WMTS ||\r\n                                                lyr.mustReproject && lyr.type === TC.Consts.layerType.WMTS && !lyr.wrap.getCompatibleMatrixSets(currentCrs)[0]) {\r\n                                                if (lyr.options.fallbackLayer && lyr.getFallbackLayer) {\r\n\r\n                                                    self.addLayer(lyr.getFallbackLayer()).then(function (l) {\r\n                                                        self.wrap.setBaseLayer(l.wrap.layer);\r\n                                                        self.baseLayer = l.wrap.parent;\r\n                                                        // GLS: Tema casita + initialExtent\r\n                                                        fitToExtent(fit);\r\n\r\n                                                        resolve(lyr);\r\n                                                    });\r\n                                                } else {\r\n                                                    reject(crsLayerError(self, lyr));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                fit = self.baseLayer === null;\r\n\r\n                                                lyr.wrap.getLayer().then(function (ollyr) {\r\n                                                    self.wrap.setBaseLayer(ollyr);\r\n                                                    self.baseLayer = lyr;\r\n\r\n                                                    // GLS: Tema casita + initialExtent\r\n                                                    fitToExtent(fit);\r\n\r\n                                                    resolve(lyr);\r\n                                                });\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //self.baseLayers.push(lyr);\r\n                                            resolve(lyr);\r\n                                        }\r\n                                    };\r\n                                    if (isCompatible) {\r\n                                        baseLayerEndFn();\r\n                                    }\r\n                                    else {\r\n                                        // Puede ser que sea una capa nueva en un capabilities nuevo que lo tenemos cacheado\r\n                                        // Antes de lanzar error, nos aseguramos de que tenemos la versin nueva\r\n                                        lyr.getCapabilitiesOnline().then(function (onlineCapabilities) {\r\n                                            lyr.capabilities = onlineCapabilities;\r\n                                            if (!lyr.isCompatible(currentCrs)) {\r\n                                                if (!lyr.type === TC.Consts.layerType.WMTS) {\r\n                                                    lyr.mustReproject = true;\r\n                                                }\r\n                                                else {\r\n                                                    const compatibleMatrixSet = lyr.wrap.getCompatibleMatrixSets(currentCrs)[0];\r\n                                                    if (compatibleMatrixSet) {\r\n                                                        lyr.wrap.setMatrixSet(compatibleMatrixSet);\r\n                                                    }\r\n                                                    else {\r\n                                                        lyr.mustReproject = true;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            baseLayerEndFn();\r\n                                        });\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (isCompatible) {\r\n                                        lyr.wrap.getLayer().then(function (l) {\r\n                                            resolve(lyr);\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        // Puede ser que sea una capa nueva en un capabilities nuevo que lo tenemos cacheado\r\n                                        // Antes de lanzar error, nos aseguramos de que tenemos la versin nueva\r\n                                        lyr.getCapabilitiesOnline().then(function (onlineCapabilities) {\r\n                                            lyr.capabilities = onlineCapabilities;\r\n                                            if (lyr.isCompatible(currentCrs)) {\r\n                                                lyr.wrap.getLayer().then(function (l) {\r\n                                                    resolve(lyr);\r\n                                                });\r\n                                            }\r\n                                            else {\r\n                                                reject(crsLayerError(self, lyr));\r\n                                            }\r\n                                        })\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                    }, function (error) {\r\n                        var err = new Error(error)\r\n                        err.layerId = layer.id;\r\n                        reject(err);\r\n                    });\r\n                }\r\n            );\r\n        });\r\n\r\n        result\r\n            .then(function (l) {\r\n                self._layerBuffer.resolve(self, l, l.isBase);\r\n                if (!l.isBase) {\r\n                    self.wrap.insertLayer(l.wrap.layer, self._layerBuffer.getResolvedVisibleLayerIndex(self, l.id));\r\n                }\r\n                self.trigger(TC.Consts.event.LAYERADD, { layer: l });\r\n                self._layerBuffer.checkMapLoad(self);\r\n                if (TC.Util.isFunction(callback)) {\r\n                    callback(l);\r\n                }\r\n            }, function (err) {\r\n                self._layerBuffer.reject(self, err);\r\n                self._layerBuffer.checkMapLoad(self);\r\n            });\r\n\r\n        const fitToExtent = function (fit) {\r\n            if (fit) {\r\n                var opt = {\r\n                    projection: self.wrap.map.getView().getProjection(),\r\n                    extent: self.initialExtent\r\n                };\r\n                var resolutions = self.baseLayer.getResolutions();\r\n                if (resolutions && resolutions.length) {\r\n                    opt.resolutions = resolutions;\r\n                }\r\n                else {\r\n                    opt.minZoom = self.wrap.map.getView().getMinZoom();\r\n                    opt.maxZoom = self.wrap.map.getView().getMaxZoom();\r\n                    var minResolution = self.baseLayer.wrap.layer.getMinResolution();\r\n                    if (minResolution !== 0) {\r\n                        opt.minResolution = minResolution;\r\n                    }\r\n                    var maxResolution = self.baseLayer.wrap.layer.getMaxResolution();\r\n                    if (maxResolution !== Number.POSITIVE_INFINITY) {\r\n                        opt.maxResolution = maxResolution;\r\n                    }\r\n                }\r\n\r\n                self.wrap.map.setView(new ol.View(opt));\r\n                self.wrap.map.getView().fit(self.initialExtent);\r\n            }\r\n        };\r\n        return result;\r\n    };\r\n\r\n\r\n    mapProto.removeLayer = function (layer) {\r\n        const self = this;\r\n\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            if (layer.unremovable) {\r\n                return reject(\"Unremovable\");\r\n            }\r\n\r\n            let found = false;\r\n            for (var i = 0; i < self.layers.length; i++) {\r\n                if (self.layers[i] === layer) {\r\n                    self.layers.splice(i, 1);\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                reject(new Error(`Layer ${layer.id} not found in map`));\r\n                return;\r\n            }\r\n            if (layer.isBase) {\r\n                for (var i = 0; i < self.baseLayers.length; i++) {\r\n                    if (self.baseLayers[i] === layer) {\r\n                        self.baseLayers.splice(i, 1);\r\n                        if (self.baseLayer === layer) {\r\n                            self.setBaseLayer(self.baseLayers[0]);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i < self.workLayers.length; i++) {\r\n                    if (self.workLayers[i] === layer) {\r\n                        self.workLayers.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n                if (layer === self.vectors) {\r\n                    self.vectors = null;\r\n                }\r\n            }\r\n\r\n            layer.wrap.getLayer().then(function (olLayer) {\r\n                self.wrap.removeLayer(olLayer);\r\n                self._layerBuffer.remove(layer.id);\r\n                self.trigger(TC.Consts.event.LAYERREMOVE, { layer: layer });\r\n                self._layerBuffer.checkMapLoad(self);\r\n                resolve(layer);\r\n            });\r\n        });\r\n    };\r\n\r\n\r\n    mapProto.insertLayer = function (layer, idx, callback) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var beforeIdx = -1;\r\n            for (var i = 0; i < self.layers.length; i++) {\r\n                if (layer === self.layers[i]) {\r\n                    beforeIdx = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            var promises = [];\r\n            promises.push(layer.wrap.getLayer());\r\n            var targetLayer = self.layers[idx];\r\n            if (targetLayer) {\r\n                promises.push(targetLayer.wrap.getLayer());\r\n            }\r\n            Promise.all(promises).then(function (olLayers) {\r\n                const olLayer = olLayers[0];\r\n                const olTargetLayer = olLayers[1];\r\n                var olIdx = -1;\r\n                if (olTargetLayer) {\r\n                    olIdx = self.wrap.getLayerIndex(olTargetLayer);\r\n                }\r\n                else {\r\n                    olIdx = self.wrap.getLayerCount();\r\n                }\r\n                if (olIdx >= 0) {\r\n                    layer.map = self;\r\n                    self.wrap.insertLayer(olLayer, olIdx);\r\n                    if (beforeIdx > -1) {\r\n                        self.layers.splice(beforeIdx, 1);\r\n                    }\r\n                    self.layers.splice(idx, 0, layer);\r\n                    self.workLayers = self.layers.filter(function (elm) {\r\n                        return !elm.isBase;\r\n                    });\r\n                    self.trigger(TC.Consts.event.LAYERORDER, { layer: layer, oldIndex: beforeIdx, newIndex: idx });\r\n                }\r\n                if (TC.Util.isFunction(callback)) {\r\n                    callback();\r\n                }\r\n                resolve(layer);\r\n            });\r\n        });\r\n    };\r\n\r\n    mapProto.setLayerIndex = function (layer, idx) {\r\n        const self = this;\r\n        const olIdx = idx - self.baseLayers.length + 1;\r\n        self.wrap.setLayerIndex(layer.wrap.layer, olIdx);\r\n    };\r\n\r\n    mapProto.putLayerOnTop = function (layer) {\r\n        var self = this;\r\n        var n = self.wrap.getLayerCount();\r\n        self.wrap.setLayerIndex(layer.wrap.layer, n - 1);\r\n    };\r\n\r\n    /*\r\n    *  setBaseLayer: Set a layer as base layer, it is added to layers collection it wasn't before\r\n    *  Parameters: TC.Layer or string, callback which accepts layer as parameter\r\n    *  Returns: TC.Layer promise\r\n    */\r\n    mapProto.setBaseLayer = async function (layer, callback) {\r\n        var self = this;\r\n        var result = null;\r\n        var found = false;\r\n\r\n        if (typeof layer === 'string') {\r\n            var i;\r\n            for (i = 0; i < self.layers.length; i++) {\r\n                if (self.layers[i].id === layer) {\r\n                    layer = self.layers[i];\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                layer = getAvailableBaseLayer.call(self, layer);\r\n                if (layer) {\r\n                    layer = await self.addLayer(TC.Util.extend(true, {}, layer, { isDefault: true, isBase:true, map: self }));\r\n                    found = true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (self.layers.indexOf(layer) < 0) {\r\n                layer.isDefault = true;\r\n                layer.isBase = true;\r\n                layer.map = self;\r\n                self.addLayer(layer);\r\n                // GLS: comento lo siguiente porque ya se va a tratar en la lnea 1838, si no, se lanza el evento 2 veces\r\n                //.then(function () {                \r\n                //self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });\r\n                //if (TC.Util.isFunction(callback)) {\r\n                //    callback();\r\n                //}\r\n                //});\r\n\r\n                //result = layer;\r\n                //return result;\r\n            }\r\n            found = true;\r\n        }\r\n        if (!found) {\r\n            TC.error('Base layer is not available');\r\n        }\r\n        else {\r\n            if (!layer.isCompatible(self.getCRS()) && (!layer.fallbackLayer || layer.fallbackLayer && !layer.fallbackLayer.isCompatible(self.getCRS()))) {\r\n                TC.error('Base layer must be reprojected');\r\n            }\r\n            else {\r\n                self.trigger(TC.Consts.event.BEFOREBASELAYERCHANGE, { oldLayer: self.getBaseLayer(), newLayer: layer });\r\n\r\n                result = layer;\r\n                await self.wrap.getMap();\r\n                const olLayer = await layer.wrap.getLayer();\r\n                await self.wrap.setBaseLayer(olLayer);\r\n                self.baseLayer = layer;\r\n                self.trigger(TC.Consts.event.BASELAYERCHANGE, { layer: layer });\r\n                if (TC.Util.isFunction(callback)) {\r\n                    callback();\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    mapProto.setView = function (view) {\r\n        const self = this;\r\n\r\n        self.view = view;\r\n        self.trigger(TC.Consts.event.VIEWCHANGE, { view: view });\r\n    };\r\n\r\n    /**\r\n     * Asigna un callback que se ejecutar cuando los controles del mapa se hayan cargado.\r\n     * @method ready\r\n     * @async\r\n     * @param {function} [callback] Funcin a ejecutar.\r\n     */\r\n    mapProto.ready = function (callback) {\r\n        var self = this;\r\n        if (TC.Util.isFunction(callback)) {\r\n            if (self.isReady) {\r\n                callback();\r\n            }\r\n            else {\r\n                self.one(TC.Consts.event.MAPREADY, callback);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Asigna un callback que se ejecutar cuando los controles y las capas iniciales del mapa se hayan cargado.\r\n     * @method loaded\r\n     * @async\r\n     * @param {function} [callback] Funcin a ejecutar.\r\n     */\r\n    mapProto.loaded = function (callback) {\r\n        var self = this;\r\n        if (TC.Util.isFunction(callback)) {\r\n            if (self.isLoaded) {\r\n                callback();\r\n            }\r\n            else {\r\n                self.one(TC.Consts.event.MAPLOAD, callback);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * Devuelve un rbol de capas del mapa.\r\n     * @method getLayerTree\r\n     * @return {TC.LayerTree}\r\n     */\r\n    mapProto.getLayerTree = function () {\r\n\r\n\r\n        var _traverse = function (o, func) {\r\n            for (var i in o.children) {\r\n                if (o.children && o.children.length > 0) {\r\n                    //bajar un nivel en el rbol\r\n                    _traverse(o.children[i], func);\r\n                }\r\n\r\n                func.apply(this, [o]);\r\n            }\r\n        };\r\n\r\n\r\n\r\n        var self = this;\r\n        var result = { baseLayers: [], workLayers: [] };\r\n        if (self.baseLayer) {\r\n            result.baseLayers[0] = self.baseLayer.getTree();\r\n        }\r\n        for (var i = 0; i < self.workLayers.length; i++) {\r\n            var tree = self.workLayers[i].getTree();\r\n\r\n            if (tree) {\r\n                result.workLayers.unshift(tree);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Aade un control al mapa.\r\n     * @method addControl\r\n     * @async\r\n     * @param {TC.Control|string} control Control a aadir o nombre del control\r\n     * @param {object} [options] Objeto de opciones de configuracin del control. Consultar el parmetro de opciones del constructor del control.\r\n     * @return {Promise} Promesa de objeto {{#crossLink \"TC.Control\"}}{{/crossLink}}\r\n     */\r\n    mapProto.addControl = function (control, options) {\r\n        const self = this;\r\n\r\n        return new Promise(function (resolve, reject) {\r\n            const _addCtl = function (ctl) {\r\n                self.controls.push(ctl);\r\n                // Lo envolvemos en Promise.resolve para asegurarse compatibilidad hacia atrs con los controles que devuelven un $.Deferred.\r\n                return Promise.resolve(ctl.register(self))\r\n                    .then(function (c) {\r\n                        if (!ctl.div.parentElement) {\r\n                            self.div.appendChild(ctl.div);\r\n                        }\r\n                        self.trigger(TC.Consts.event.CONTROLADD, { control: ctl });\r\n                        return c;\r\n                    })\r\n                    .catch(function (err) {\r\n                        reject(err instanceof Error ? err : Error(err));\r\n                    });\r\n            };\r\n            if (typeof control === 'string') {\r\n                control = control.substr(0, 1).toUpperCase() + control.substr(1);\r\n                TC.loadJS(\r\n                    !TC.Control || !TC.control[control],\r\n                    [TC.apiLocation + 'TC/control/' + control],\r\n                    function () {\r\n                        _addCtl(new TC.control[control](null, options)).then(function (ctl) {\r\n                            resolve(ctl)\r\n                        });\r\n                    }\r\n                );\r\n            }\r\n            else {\r\n                _addCtl(control).then(function (ctl) {\r\n                    resolve(ctl);\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Devuelve la lista de controles que son de la clase especificada.\r\n     * @method getControlsByClass\r\n     * @param {function|string} classObj Nombre de la clase o funcin constructora de la clase.\r\n     * @return {array}\r\n     */\r\n    mapProto.getControlsByClass = function (classObj) {\r\n        var self = this;\r\n        var result = [];\r\n        var obj = classObj;\r\n        if (typeof classObj === 'string') {\r\n            obj = window;\r\n            var namespaces = classObj.split('.');\r\n            for (var i = 0; i < namespaces.length; i++) {\r\n                obj = obj[namespaces[i]];\r\n                if (!obj) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (TC.Util.isFunction(obj)) {\r\n            for (var i = 0; i < self.controls.length; i++) {\r\n                var ctl = self.controls[i];\r\n                if (ctl instanceof obj) {\r\n                    result.push(ctl);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    mapProto.getControlById = function (id) {\r\n        const self = this;\r\n        for (var i = 0, len = self.controls.length; i < len; i++) {\r\n            const ctl = self.controls[i];\r\n            if (ctl.id === id) {\r\n                return ctl;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    mapProto.getDefaultControl = function () {\r\n        const self = this;\r\n        var candidate;\r\n        if (self.options.defaultActiveControl) {\r\n            candidate = self.getControlsByClass('TC.control.' + self.options.defaultActiveControl.substr(0, 1).toUpperCase() + self.options.defaultActiveControl.substr(1))[0];\r\n        }\r\n        if (!candidate) {\r\n            candidate = self.getControlsByClass('TC.control.MultiFeatureInfo')[0];\r\n            if (candidate) {\r\n                candidate = candidate.lastCtrlActive;\r\n            }\r\n            else {\r\n                candidate = self.getControlsByClass('TC.control.FeatureInfo')[0];\r\n            }\r\n        }\r\n        return candidate;\r\n    };\r\n\r\n    /**\r\n     * Devuelve el primer control del mapa que sea de la clase {{#crossLink \"TC.control.LoadingIndicator\"}}{{/crossLink}}.\r\n     * @method getLoadingIndicator\r\n     * @return {TC.control.LoadingIndicator}\r\n     */\r\n    mapProto.getLoadingIndicator = function () {\r\n        var result = null;\r\n        var ctls = this.getControlsByClass('TC.control.LoadingIndicator');\r\n        if (ctls.length) {\r\n            result = ctls[0];\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Establece la extensin del mapa.\r\n     * @method setExtent\r\n     * @param {array} extent Array de cuatro nmeros que representan las coordenadas x mnima, y mnima, x mxima e y mxima respectivamente.\r\n     * @param {object} [options] Objeto de opciones.\r\n     * @param {boolean} [options.animate=true] Establece si se realiza una animacin al cambiar la extensin.\r\n     * La unidad de las coordenadas es la correspondiente al CRS del mapa.\r\n     */\r\n    mapProto.setExtent = function (extent, options) {\r\n        return this.wrap.setExtent(extent, options);\r\n    };\r\n\r\n    /**\r\n     * Obtiene la extensin actual del mapa.\r\n     * @method getExtent\r\n     * @return {array} Array de cuatro nmeros que representan las coordenadas x mnima, y mnima, x mxima e y mxima respectivamente.\r\n     * La unidad de las coordenadas es la correspondiente al CRS del mapa.\r\n     */\r\n    mapProto.getExtent = function () {\r\n        return this.wrap.getExtent();\r\n    };\r\n\r\n    /**\r\n     * Establece el centro del mapa.\r\n     * @method setCenter\r\n     * @param {array} coord Array de dos nmeros que representan la coordenada del punto en las unidades correspondientes al CRS del mapa.\r\n     * @param {object} [options] Objeto de opciones.\r\n     * @param {boolean} [options.animate=true] Establece si se realiza una animacin al centrar.\r\n     */\r\n    mapProto.setCenter = function (coord, options) {\r\n        return this.wrap.setCenter(coord, options);\r\n    };\r\n\r\n    mapProto.getCenter = function () {\r\n        return this.wrap.getCenter();\r\n    };\r\n\r\n    mapProto.setRotation = function (rotation) {\r\n        this.wrap.setRotation(rotation);\r\n    };\r\n\r\n    mapProto.getRotation = function () {\r\n        return this.wrap.getRotation();\r\n    };\r\n\r\n    mapProto.getViewHTML = function () {\r\n        return this.wrap.getViewport();\r\n    };\r\n\r\n\r\n    mapProto.getCompatibleCRS = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const layers = options.layers || self.workLayers.concat(self.baseLayer);\r\n        const crsLists = layers\r\n            .filter(function (layer) {\r\n                return layer.isRaster();\r\n            }) // capas raster\r\n            .map(function (layer) {\r\n                return layer.getCompatibleCRS({ normalized: true, includeFallback: options.includeFallbacks });\r\n            });\r\n        const otherCrsLists = crsLists.slice(1);\r\n        return crsLists[0].filter(function (elm) {\r\n            return otherCrsLists.every(function (crsList) {\r\n                return crsList.indexOf(elm) >= 0;\r\n            });\r\n        });\r\n    };\r\n\r\n    mapProto.loadProjections = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        return new Promise(function (resolve, reject) {\r\n            const crsList = options.crsList || [];\r\n            Promise.all(crsList\r\n                .map(function (crs) {\r\n                    return TC.getProjectionData({\r\n                        crs: TC.Util.getCRSCode(crs)\r\n                    });\r\n                })).then(function (responses) {\r\n                    var projList = responses\r\n                        .filter(function (response) {\r\n                            return response.status === 'ok' && response.number_result > 0;\r\n                        })\r\n                        .map(function (response) {\r\n                            const projData = response.results[0];\r\n                            const code = 'EPSG:' + projData.code;\r\n                            TC.loadProjDef({\r\n                                crs: code,\r\n                                def: projData.def,\r\n                                name: projData.name\r\n                            });\r\n                            return {\r\n                                code: code,\r\n                                name: projData.name,\r\n                                proj4: projData.proj4,\r\n                                unit: projData.unit\r\n                            };\r\n                        });\r\n                    if (options.orderBy) {\r\n                        projList = projList\r\n                            .sort(TC.Util.getSorterByProperty(options.orderBy));\r\n                    }\r\n                    resolve(projList);\r\n                },\r\n                function (error) {\r\n                    reject(error);\r\n                });\r\n        });\r\n    };\r\n\r\n    mapProto.setProjection = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        return new Promise(function (resolve, reject) {\r\n            var baseLayer;\r\n            if (options.crs) {\r\n                if (options.baseLayer) {\r\n                    baseLayer = options.baseLayer;\r\n                }\r\n                else if (options.allowFallbackLayer) {\r\n                    // Cambiamos de capa de fondo si es mejor o no hay ms remedio\r\n                    if (!self.baseLayer.isCompatible(options.crs) &&\r\n                        self.baseLayer.wrap.getCompatibleMatrixSets(options.crs).length === 0) {\r\n                        if (self.baseLayer.options.fallbackLayer) {\r\n                            baseLayer = self.baseLayer.getFallbackLayer();\r\n                        }\r\n                    }\r\n                    else if (self.baseLayer.firstOption && (self.baseLayer.firstOption.isCompatible(options.crs) ||\r\n                        self.baseLayer.firstOption.wrap.getCompatibleMatrixSets(options.crs).length > 0)) {\r\n                        baseLayer = self.baseLayer.firstOption;\r\n                    }\r\n                }\r\n                if (!baseLayer) {\r\n                    baseLayer = self.baseLayer;\r\n                }\r\n\r\n                // 03/04/2019 GLS: esperamos a que termine de aadirse la capa porque si no se duplica en la gestin de la carga del CRS.\r\n                const loadProj = function () {\r\n                    TC.loadProjDef({\r\n                        crs: options.crs,\r\n                        callback: function () {\r\n                            const oldCrs = self.crs;\r\n                            const setProjection = function (baseLayer) {\r\n\r\n                                const _setProjection = function () {\r\n                                    const layerProjectionOptions = TC.Util.extend({}, options, { oldCrs: self.crs });\r\n                                    const setLayerProjection = function (layer) {\r\n                                        layer.setProjection(layerProjectionOptions);\r\n                                    };\r\n                                    if (baseLayer.isCompatible(options.crs) || baseLayer.wrap.getCompatibleMatrixSets(options.crs).length > 0) {\r\n                                        baseLayer.setProjection(layerProjectionOptions);\r\n                                        self.wrap.setProjection(TC.Util.extend({}, options, { baseLayer: baseLayer }));\r\n                                        self.crs = options.crs;\r\n                                        // En las capas base disponibles, evaluar su compatibilidad con el nuevo CRS\r\n                                        self.baseLayers\r\n                                            .filter(function (layer) {\r\n                                                return layer !== baseLayer;\r\n                                            })\r\n                                            .forEach(setLayerProjection);\r\n                                        // Reprojectamos capas cargadas\r\n                                        self.workLayers.forEach(setLayerProjection);\r\n                                        const resolveChange = function () {\r\n                                            self.trigger(TC.Consts.event.PROJECTIONCHANGE, { oldCrs: oldCrs, newCrs: options.crs });\r\n                                            resolve();\r\n                                        };\r\n                                        if (baseLayer && baseLayer !== self.baseLayer) {\r\n                                            self.setBaseLayer(baseLayer, resolveChange);\r\n                                        }\r\n                                        else {\r\n                                            resolveChange();\r\n                                        }\r\n                                    }\r\n                                    else if (baseLayer.fallbackLayer) {\r\n                                        setProjection(baseLayer.fallbackLayer);\r\n                                    } else {\r\n                                        reject(Error('Layer has no fallback'));\r\n                                    }\r\n                                };\r\n\r\n                                if (baseLayer.type === TC.Consts.layerType.WMS || baseLayer.type === TC.Consts.layerType.WMTS) {\r\n                                    baseLayer.getCapabilitiesPromise().then(_setProjection);\r\n                                } else {\r\n                                    _setProjection();\r\n                                }\r\n                            };\r\n\r\n                            setProjection(baseLayer);\r\n                        }\r\n                    });\r\n                };\r\n\r\n                if (self.baseLayers.indexOf(baseLayer) < 0) {\r\n                    self.addLayer(baseLayer).then(loadProj);\r\n                } else {\r\n                    loadProj();\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n    mapProto.getMetersPerUnit = function () {\r\n        return this.wrap.getMetersPerUnit();\r\n    };\r\n\r\n    /**\r\n     * Obtiene una coordenada a partir de una posicin del rea de visualizacin del mapa en pxeles.\r\n     * @method getCoordinateFromPixel\r\n     * @param {array} xy Coordenada en pxeles de la posicin en el rea de visualizacin.\r\n     * @return {array} Array de dos nmeros que representa las coordenada del punto en las unidades correspondientes al CRS del mapa.\r\n     */\r\n    mapProto.getCoordinateFromPixel = function (xy) {\r\n        return this.wrap.getCoordinateFromPixel(xy);\r\n    };\r\n\r\n    /**\r\n     * Obtiene una posicin en el rea de visualizacin a partir de una coordenada.\r\n     * @method getCoordinateFromPixel\r\n     * @param {array} coord Coordenada en el mapa.\r\n     * @return {array} Array de dos nmeros que representa las posicin del punto en pxeles.\r\n     */\r\n    mapProto.getPixelFromCoordinate = function (coord) {\r\n        return this.wrap.getPixelFromCoordinate(coord);\r\n    };\r\n\r\n    /**\r\n     * Establece la extensin del mapa de forma que abarque todas las entidades geogrficas pasadas por parmetro.\r\n     * @method zoomToFeatures\r\n     * @param {array} features Array de entidades geogrficas. Si est vaco este mtodo no hace nada.\r\n     * @param {object} [options] Objeto de opciones de zoom.\r\n     * @param {number} [options.pointBoundsRadius=30] Radio en metros del rea alrededor del punto que se respetar al hacer zoom.\r\n     * @param {number} [options.extentMargin=0.2] Tamao del margen que se aplicar a la extensin total de todas las entidades. \r\n     * @param {boolean} [options.animate=false] Realizar animacin al hacer el zoom. \r\n     * El valor es la relacin resultante de la diferencia de dimensiones entre la extensin ampliada y la original relativa a la original.\r\n     */\r\n    mapProto.zoomToFeatures = function (features, options) {\r\n        var self = this;\r\n        if (features.length > 0) {\r\n            var bounds = [Infinity, Infinity, -Infinity, -Infinity];\r\n            var opts = options || {};\r\n            var radius = opts.pointBoundsRadius || self.options.pointBoundsRadius;\r\n            radius = radius / self.getMetersPerUnit();\r\n            var extentMargin = opts.extentMargin;\r\n            if (typeof extentMargin !== 'number') {\r\n                extentMargin = self.options.extentMargin;\r\n            }\r\n            for (var i = 0; i < features.length; i++) {\r\n                var b = features[i].getBounds();\r\n                if (b) {\r\n                    bounds[0] = Math.min(bounds[0], b[0]);\r\n                    bounds[1] = Math.min(bounds[1], b[1]);\r\n                    bounds[2] = Math.max(bounds[2], b[2]);\r\n                    bounds[3] = Math.max(bounds[3], b[3]);\r\n                }\r\n            }\r\n            if (bounds[2] - bounds[0] === 0) {\r\n                bounds[0] = bounds[0] - radius;\r\n                bounds[2] = bounds[2] + radius;\r\n            }\r\n            if (bounds[3] - bounds[1] === 0) {\r\n                bounds[1] = bounds[1] - radius;\r\n                bounds[3] = bounds[3] + radius;\r\n            }\r\n            if (extentMargin) {\r\n                var dx = (bounds[2] - bounds[0]) * extentMargin / 2;\r\n                var dy = (bounds[3] - bounds[1]) * extentMargin / 2;\r\n                bounds[0] = bounds[0] - dx;\r\n                bounds[1] = bounds[1] - dy;\r\n                bounds[2] = bounds[2] + dx;\r\n                bounds[3] = bounds[3] + dy;\r\n            }\r\n            if (self.options.maxExtent) {\r\n                bounds[0] = Math.max(bounds[0], self.options.maxExtent[0]);\r\n                bounds[1] = Math.max(bounds[1], self.options.maxExtent[1]);\r\n                bounds[2] = Math.min(bounds[2], self.options.maxExtent[2]);\r\n                bounds[3] = Math.min(bounds[3], self.options.maxExtent[3]);\r\n            }\r\n            self.wrap.setExtent(bounds, opts);\r\n\r\n            if (self.on3DView) { // GLS: Necesito diferenciar un zoom programtico de un zoom del usuario para la gestin del zoom en 3D\r\n                self._on3DZoomTo({ extent: bounds });\r\n            }\r\n        }\r\n    };\r\n\r\n    mapProto._on3DZoomTo = function (options) {\r\n        const self = this;\r\n        \r\n        options = options || {};\r\n\r\n        if (self.on3DView && options.extent && options.extent.length === 4) {\r\n            // GLS: Necesito diferenciar un zoom programtico de un zoom del usuario para la gestin del zoom en 3D\r\n            if (options.reprojected) {\r\n                self.trigger(TC.Consts.event.ZOOMTO, options);\r\n            } else {\r\n                let extent = options.extent;\r\n                let coordsXY = self.view3D.view2DCRS !== self.view3D.crs ?\r\n                    TC.Util.reproject(extent.slice(0, 2), self.view3D.view2DCRS, self.view3D.crs) :\r\n                    extent.slice(0, 2);\r\n\r\n                let coordsXY2 = self.view3D.view2DCRS !== self.view3D.crs ?\r\n                    TC.Util.reproject(extent.slice(2), self.view3D.view2DCRS, self.view3D.crs) :\r\n                    extent.slice(2);\r\n\r\n                options.extent = coordsXY.concat(coordsXY2);\r\n\r\n                self.trigger(TC.Consts.event.ZOOMTO, options);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Establece la extensin del mapa de forma que abarque todas los marcadores que existen en l.\r\n     * El mtodo espera a todos los marcadores pendientes de incluir, dado que el mtodo {{#crossLink \"TC.Map/addMarker:method\"}}{{/crossLink}} es asncrono.\r\n     * @method zoomToMarkers\r\n     */\r\n    mapProto.zoomToMarkers = function (options) {\r\n        var self = this;\r\n        Promise.all(self._markerPromises).then(function () {\r\n            var markers = [];\r\n            for (var i = 0; i < self.workLayers.length; i++) {\r\n                var layer = self.workLayers[i];\r\n                if (layer.type === TC.Consts.layerType.VECTOR) {\r\n                    for (var j = 0; j < layer.features.length; j++) {\r\n                        var feature = layer.features[j];\r\n                        if (feature instanceof TC.feature.Marker) {\r\n                            markers.push(feature);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            self.zoomToFeatures(markers, options);\r\n            self._markerPromises = [];\r\n        });\r\n    };\r\n\r\n    mapProto.zoomToLayer = function (layer, options) {\r\n        const self = this;\r\n        layer = self.getLayer(layer);\r\n        if (layer.isRaster()) {\r\n            const extent = layer.getExtent();\r\n            if (extent) {\r\n                options = options || {};\r\n                if (typeof options.extentMargin !== 'number') {\r\n                    options.extentMargin = self.options.extentMargin;\r\n                }\r\n                self.setExtent(extent, options);\r\n\r\n                if (self.on3DView) { // GLS: Necesito diferenciar un zoom programtico de un zoom del usuario para la gestin del zoom en 3D\r\n                    self._on3DZoomTo({ extent: extent, reprojected: true });\r\n                    /* reprojected: true:\r\n                        Al obtener el extent de la capa desde el capabilities ya se gestiona que el CRS del mapa est en 4326\r\n                        porque map.getCRS ya gestiona si estamos en 3D o no por lo que el extent ya llega en geogrficas.\r\n                    */\r\n                }                \r\n            }\r\n        }\r\n        else {\r\n            if (layer.features && layer.features.length) {\r\n                self.zoomToFeatures(layer.features, options);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Obtiene una capa por su identificador o devuelve la propia capa.\r\n     * @method getLayer\r\n     * @param {string|TC.Layer} layer Identificador de la capa u objeto de capa.\r\n     * @return {TC.Layer}\r\n     */\r\n    mapProto.getLayer = function (layer) {\r\n        const self = this;\r\n        var result = null;\r\n        if (typeof layer === 'string') {\r\n            for (var i = 0; i < self.layers.length; i++) {\r\n                if (self.layers[i].id === layer) {\r\n                    result = self.layers[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else if (TC.Layer && layer instanceof TC.Layer && layer.map === self) {\r\n            result = layer;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _getVectors = function (map) {\r\n        var result;\r\n        if (!map.vectors) {\r\n            result = map.addLayer({\r\n                id: TC.getUID(), title: TC.i18n[map.options.locale]['vectorLayer'], type: TC.Consts.layerType.VECTOR\r\n            });\r\n            map.vectors = result;\r\n            result.then(function (vectors) {\r\n                map.vectors = vectors;\r\n            });\r\n        }\r\n        else {\r\n            result = Promise.resolve(map.vectors);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Aade un punto al mapa. Si no se especifica una capa en el parmetro de opciones se aadir a una capa vectorial destinada a aadir entidades geogrficas.\r\n     * Esta capa se crea al aadir por primera vez una entidad sin especificar capa.\r\n     * @method addPoint\r\n     * @async\r\n     * @param {array} coord Array de dos nmeros representando la coordenada del punto en las unidades del CRS del mapa.\r\n     * @param {TC.cfg.PointStyleOptions} [options] Opciones del punto.\r\n     */\r\n    mapProto.addPoint = function (coord, options) {\r\n        var self = this;\r\n        if (options && options.layer) {\r\n            var layer = self.getLayer(options.layer);\r\n            if (layer) {\r\n                layer.addPoint(coord, TC.Util.extend(true, {}, options, { layer: layer }));\r\n            }\r\n            else {\r\n                throw new Error('Layer \"' + options.layer + '\" not found');\r\n            }\r\n        }\r\n        else {\r\n            _getVectors(self).then(function (vectors) {\r\n                vectors.addPoint(coord, options);\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Aade un marcador puntual al mapa. Si no se especifica una capa en el parmetro de opciones se aadir a una capa vectorial destinada a aadir entidades geogrficas.\r\n     * Esta capa se crea al aadir por primera vez una entidad sin especificar capa.\r\n     * @method addMarker\r\n     * @async\r\n     * @param {array} coord Array de dos nmeros representando la coordenada del punto en las unidades del CRS del mapa.\r\n     * @param {TC.cfg.MarkerStyleOptions} [options] Opciones del marcador.\r\n     */\r\n    mapProto.addMarker = function (coord, options) {\r\n        var self = this;\r\n        if (options && options.layer) {\r\n            var layer = self.getLayer(options.layer);\r\n            if (layer) {\r\n                self._markerPromises.push(layer.addMarker(coord, TC.Util.extend(true, {}, options, { layer: layer })));\r\n            }\r\n            else {\r\n                self._markerPromises.push(Promise.reject(new Error('Layer \"' + options.layer + '\" not found')));\r\n            }\r\n        }\r\n        else {\r\n            // Se aade una promise ms para evitar que zoomToMarkers salte antes de poblarse el array _markerPromises.\r\n            self._markerPromises.push(new Promise(function (resolve, reject) {\r\n                _getVectors(self).then(function (vectors) {\r\n                    vectors.addMarker(coord, options).then(function (marker) {\r\n                        resolve(marker);\r\n                    });\r\n                });\r\n            }));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Aade una polilnea al mapa. Si no se especifica una capa en el parmetro de opciones se aadir a una capa vectorial destinada a aadir entidades geogrficas.\r\n     * Esta capa se crea al aadir por primera vez una entidad sin especificar capa.\r\n     * @method addPolyline\r\n     * @async\r\n     * @param {array} coords Array de arrays de dos nmeros representando las coordenadas de los vrtices en las unidades del CRS del mapa.\r\n     * @param {object} [options] Opciones de la polilnea.\r\n     */\r\n    mapProto.addPolyline = function (coords, options) {\r\n        var self = this;\r\n        if (options && options.layer) {\r\n            var layer = self.getLayer(options.layer);\r\n            if (layer) {\r\n                layer.addPolyline(coords, TC.Util.extend(true, {}, options, { layer: layer }));\r\n            }\r\n            else {\r\n                throw new Error('Layer \"' + options.layer + '\" not found');\r\n            }\r\n        }\r\n        else {\r\n            _getVectors(self).then(function (vectors) {\r\n                vectors.addPolyline(coords, options);\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Aade un polgono al mapa. Si no se especifica una capa en el parmetro de opciones se aadir a una capa vectorial destinada a aadir entidades geogrficas.\r\n     * Esta capa se crea al aadir por primera vez una entidad sin especificar capa.\r\n     * @method addPolygon\r\n     * @async\r\n     * @param {array} coords Array que contiene anillos. Estos a su vez son arrays de arrays de dos nmeros representando las coordenadas de los vrtices en las unidades del CRS del mapa.\r\n     * El primer anillo es el exterior y el resto son islas. No es necesario cerrar los anillos (poner el mismo vrtice al principio y al final).\r\n     * @param {object} [options] Opciones del polgono.\r\n     */\r\n    mapProto.addPolygon = function (coords, options) {\r\n        var self = this;\r\n        if (options && options.layer) {\r\n            var layer = self.getLayer(options.layer);\r\n            if (layer) {\r\n                layer.addPolygon(coords, TC.Util.extend(true, {}, options, { layer: layer }));\r\n            }\r\n            else {\r\n                throw new Error('Layer \"' + options.layer + '\" not found');\r\n            }\r\n        }\r\n        else {\r\n            _getVectors(self).then(function (vectors) {\r\n                vectors.addPolygon(coords, options);\r\n            });\r\n        }\r\n    };\r\n\r\n\r\n\r\n\r\n    mapProto.getBaseLayer = function () {\r\n        return this.baseLayer || this.baseLayers[0];\r\n    };\r\n\r\n    mapProto.getResolutions = function () {\r\n        return this.wrap.getResolutions();\r\n    };\r\n\r\n    mapProto.getResolution = function () {\r\n        return this.wrap.getResolution();\r\n    };\r\n\r\n    mapProto.setResolution = function (resolution) {\r\n        return this.wrap.setResolution(resolution);\r\n    };\r\n\r\n    mapProto.exportFeatures = async function (features, options) {\r\n        var self = this;\r\n        options = options || {};\r\n        var loadingCtl = self.getLoadingIndicator();\r\n        var waitId = loadingCtl && loadingCtl.addWait();\r\n        // Eliminamos las elevaciones nulas\r\n        // En GPX hay un bug con los valores cero, que hace que se tome el valor de elevacin del punto previo, por eso ponemos NaN.\r\n        const elevSubst = options.format === TC.Consts.format.GPX ? Number.NaN : 0;\r\n        features.forEach(function (feature, idx) {\r\n            // Decodificamos entidades HTML de la feature\r\n            const data = feature.getData();\r\n            for (let key in data) {\r\n                if (/&(\\w+|#\\d{2,4});/g.test(key)) {\r\n                    const value = data[key];\r\n                    const newData = {};\r\n                    const elm = document.createElement('div');\r\n                    elm.innerHTML = key;\r\n                    newData[elm.innerText] = value;\r\n                    feature.unsetData(key);\r\n                    feature.setData(newData);\r\n                }\r\n            }\r\n            // Formateamos el valor de elevacin\r\n            var flatCoords = feature.getCoords({ pointArray: true });\r\n            if (flatCoords.some(function (point) {\r\n                return point[2] === null;\r\n            })) {\r\n                const newFeature = feature.clone();\r\n                newFeature.setId(feature.id);\r\n                features[idx] = feature = newFeature;\r\n                flatCoords = feature.getCoords({ pointArray: true });\r\n                flatCoords.forEach(function (point) {\r\n                    if (point[2] === null) {\r\n                        point[2] = elevSubst;\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        const format = options.format || \"\";\r\n        if (format === TC.Consts.format.SHP) {\r\n            const defaultEncoding = \"ISO-8859-1\"\r\n            //generar shape\r\n\r\n            //agrupar por capa\r\n            var layers = features.reduce(function (rv, x) {\n                var id = x.id.substr(0, x.id.lastIndexOf(\".\"));\r\n                //var id = x.layer? (typeof(x.layer)===\"string\"?x.layer:x.layer.id) :x.id.substr(0, x.id.lastIndexOf(\".\"));\r\n                (rv[id] = rv[id] || []).push(x);\n                return rv;\n            }, {});             \r\n            \r\n            const getInnerType = function (type) {\r\n\r\n                switch (true) {\r\n                    case type === 'TC.feature.Point':\r\n                        return 'POINT';\r\n                        break;\r\n                    case type === 'TC.feature.Polygon':\r\n                    case type === 'TC.feature.MultiPolygon':\r\n                        return 'POLYGON';\r\n                        break;\r\n                    case type === 'TC.feature.Polyline':\r\n                    case type === 'TC.feature.MultiPolyline':\r\n                        return 'POLYLINE';\r\n                        break;\r\n                }\r\n                return 'NULL';\r\n            }\r\n            const proj = await TC.getProjectionData({ crs: self.crs });\r\n            \r\n            var arrPromises = [];\r\n            for (var layerId in layers) {\r\n                //agrupar las features por tipos\r\n                var groups = groups = layers[layerId].reduce(function (rv, x) {\r\n                    (rv[x.CLASSNAME] = rv[x.CLASSNAME] || []).push(x);\r\n                    return rv;\r\n                }, {});\r\n                for (var group in groups) {\r\n                    arrPromises.push(new Promise(function (resolve) {\r\n                        const _group = group;\r\n                        const _features = groups[_group];\r\n                        const data = _features.reduce(function (prev, curr) {\r\n                            const data = {};\r\n                            for (var key in curr.data) {\r\n                                const val = curr.data[key];\r\n                                data[key] = typeof val === 'string' ? val.replace(/\\/g, \"&bull;\") : val;\r\n                            }\r\n                            if (curr.getStyle().label && !curr.data[\"name\"])\r\n                                data[\"name\"] = curr.getStyle().label;\r\n                            return prev.concat([data])\r\n                        }, []);\r\n                        const geometries = _features.reduce(function (prev, curr) {\r\n                            //No se porque no le gusta las geometrias polyline de la herramienta draw por tanto las convierto a multipolyline\r\n                            if (curr instanceof TC.feature.Polyline)\r\n                                curr = new TC.feature.MultiPolyline(curr.getCoords(), curr.options)\r\n                            //si el sistema de referencia es distinto a EPSG:4326 reproyecto las geometrias\t\t\t\t\t\t\t\r\n                            return prev.concat([curr.geometry]);\r\n                        }, []);\r\n                        //generamos el un shape mas sus allegados por grupo\r\n                        TC.loadJS(!window.shpWrite, TC.apiLocation + 'lib/shp-write/shp-write', async function () {\r\n                            shpWrite.write(data\r\n                                , getInnerType(_group)\r\n                                , geometries\r\n                                , async function (vacia, content) {\r\n                                    const timestamp = options.fileName.substring(options.fileName.lastIndexOf(\"_\", options.fileName.lastIndexOf(\"_\") - 1) + 1);                                    \r\n                                    const fileName = layerId + (Object.keys(groups).length > 1 ? \"_\" + getInnerType(_group) : \"\") + (timestamp ? \"_\" + timestamp:\"\");\r\n                                    resolve({ \"fileName\": fileName, \"content\": content });\r\n                                });\r\n                        });\r\n                    }));\r\n                }\r\n            }\r\n            \r\n            Promise.all(arrPromises).then(function (resolves) {\r\n                //creamos el fichero zip\r\n                TC.loadJS(!window.JSZip, TC.apiLocation + 'lib/jszip/jszip', async function () {\r\n                    const zip = new JSZip();\r\n                    for (var i = 0; i < resolves.length; i++) {\r\n                        zip.file(resolves[i].fileName + \".shp\", resolves[i].content.shp.buffer);\r\n                        zip.file(resolves[i].fileName + \".shx\", resolves[i].content.shx.buffer);\r\n                        zip.file(resolves[i].fileName + \".dbf\", resolves[i].content.dbf.buffer);\r\n                        zip.file(resolves[i].fileName + \".prj\", proj.results[0].wkt);\r\n                        zip.file(resolves[i].fileName + \".cst\", defaultEncoding);\r\n                        zip.file(resolves[i].fileName + \".cpg\", defaultEncoding);\r\n                    }\r\n                    zip.generateAsync({ type: \"blob\" }).then(function (blob) {\r\n                        TC.Util.downloadBlob(options.fileName + \".zip\", blob);\r\n                        loadingCtl && loadingCtl.removeWait(waitId);\r\n                    }, function (err) {\r\n                        loadingCtl && loadingCtl.removeWait(waitId);\r\n                        throw err\r\n                    });\r\n                })\r\n            });\r\n            return;\r\n        }        \r\n        if (format === TC.Consts.format.GPKG) {\r\n            const fieldDataType = function (value) {\r\n                var name = ''\r\n                switch (typeof (value)) {\r\n                    case \"string\":\r\n                        name = geopackage.DataTypes.GPKG_DT_TEXT_NAME;\r\n                        break;\r\n                    case \"number\":\r\n                        if (value % 1 === 0)\r\n                            name = geopackage.DataTypes.GPKG_DT_INTEGER_NAME;\r\n                        else\r\n                            name = geopackage.DataTypes.GPKG_DT_FLOAT_NAME;\r\n                        break;\r\n                    case \"boolean\":\r\n                        name = geopackage.DataTypes.GPKG_DT_BOOLEAN_NAME;\r\n                        break;\r\n                    default:\r\n                        name = geopackage.DataTypes.GPKG_DT_TEXT_NAME;\r\n                    //date y datetime\r\n                }\r\n                return geopackage.DataTypes.fromName(name);\r\n            }\r\n\r\n            const currentCrs = self.crs;\r\n            TC.loadJS(!window.geopackage, [TC.apiLocation + 'lib/geopackage/geopackage'], function () {\r\n                TC.loadJS(!window.require || !require('wkx'), [TC.apiLocation + 'lib/wkx/wkx'], async function () {\r\n                    geopackage.create().then(async function (myPackage) {\r\n                        \r\n\r\n                        var arrPromises = [];\r\n\r\n                        var srs_id = currentCrs.substr(currentCrs.indexOf(\":\") + 1);\r\n                        if (!myPackage.getSpatialReferenceSystemDao().queryForId(srs_id)) {\r\n                            var srsDao = myPackage.getSpatialReferenceSystemDao();\r\n                            var newSRS = srsDao.createObject();\r\n                            var projData = await TC.getProjectionData({ crs: currentCrs });\r\n                            newSRS.srs_name = currentCrs;\r\n                            newSRS.srs_id = projData.results[0].code;\r\n                            newSRS.organization = currentCrs.substr(0, currentCrs.indexOf(\":\"));\r\n                            newSRS.organization_coordsys_id = projData.results[0].code;\r\n                            newSRS.definition = projData.results[0].proj4.trim();\r\n                            newSRS.definition_12_063 = projData.results[0].wkt.trim();\r\n                            newSRS.description = projData.results[0].name;\r\n                            srsDao.create(newSRS);\r\n                        }\r\n                        //agrupar por capa\r\n                        const timestamp = options.fileName.substring(options.fileName.lastIndexOf(\"_\", options.fileName.lastIndexOf(\"_\") - 1) + 1); \r\n                        var layers = features.reduce(function (rv, x) {\n                            var id = typeof (x.id) === \"string\" ? x.id.substr(0, x.id.lastIndexOf(\".\")) : options.fileName;\r\n                            //var id = x.layer ? (typeof (x.layer) === \"string\" ? x.layer : x.layer.id) : x.id.substr(0, x.id.lastIndexOf(\".\"));\r\n                            (rv[id] = rv[id] || []).push(x);                            \n                            return rv;\n                        }, {});\r\n                        for (var layerId in layers) {\r\n                            //agrupar las features por tipos\r\n                            var groups = layers[layerId].reduce(function (rv, x) {\r\n                                (rv[x.CLASSNAME] = rv[x.CLASSNAME] || []).push(x);\r\n                                return rv;\r\n                            }, {});\r\n                            for (var group in groups) {\r\n                                arrPromises.push(new Promise(async function (resolve) {\r\n                                    const _features = groups[group];\r\n                                    //crear columnas\r\n                                    var FeatureColumn = geopackage.FeatureColumn;\r\n                                    var GeometryColumns = geopackage.GeometryColumns;\r\n                                    var i = 0;\r\n\r\n                                    const geometryType = _features[0].CLASSNAME.substr(_features[0].CLASSNAME.lastIndexOf(\".\") + 1).replace(\"Polyline\", \"LineString\").replace(\"Marker\", \"Point\");\r\n                                    const tableName = layerId + (Object.keys(groups).length > 1 ? \"_\" + geometryType : \"\")// + (timestamp ? \"_\" + timestamp : \"\");\r\n                                    var columns = [];\r\n                                    var dataColumns = [];\r\n                                    var pkColumnName = \"id\";\r\n\r\n                                    if (features[0].hasOwnProperty(\"id\") || features[0].hasOwnProperty(\"ID\"))\r\n                                        columns.push(FeatureColumn.createPrimaryKeyColumnWithIndexAndName(i++, pkColumnName));\r\n                                    columns.push(FeatureColumn.createGeometryColumn(i++, 'geometry', geometryType.toUpperCase(), true, null));                                    \r\n\r\n                                    var bounds = [Infinity, Infinity, -Infinity, -Infinity];\r\n                                    for (var j = 0; j < _features.length; j++) {\r\n                                        var b = _features[j].getBounds();\r\n                                        if (b) {\r\n                                            bounds[0] = Math.min(bounds[0], b[0]);\r\n                                            bounds[1] = Math.min(bounds[1], b[1]);\r\n                                            bounds[2] = Math.max(bounds[2], b[2]);\r\n                                            bounds[3] = Math.max(bounds[3], b[3]);\r\n                                        }\r\n                                    }\r\n\r\n                                    for (var x in (_features[0].data || _features[0].attributes)) {\r\n                                        var fieldName = _features[0].attributes && _features[0].attributes[x] ? _features[0].attributes[x].name : x;\r\n                                        if (fieldName.toLowerCase() === 'id') continue;\r\n                                        var fieldValue = _features[0].data[fieldName];\r\n                                        var c = FeatureColumn.createColumnWithIndex(i++, fieldName, fieldDataType(fieldValue));\r\n                                        columns.push(c);\r\n                                        //dataColumns.push(c);\r\n                                    }\r\n                                    //si alguna feature tiene simbologa de tipo texto se aade como una columna ms a la tabla llamada \"name\"\r\n                                    if (_features.some(function (f) { return f.getStyle().label && ! f.data.name})) {\r\n                                        var c = FeatureColumn.createColumnWithIndex(i++, \"name\", geopackage.DataTypes.GPKG_DT_TEXT_NAME);\r\n                                        columns.push(c);\r\n                                    }\r\n\r\n\r\n                                    var geometryColumns = new GeometryColumns();\r\n                                    geometryColumns.table_name = tableName;\r\n                                    geometryColumns.column_name = 'geometry';\r\n                                    geometryColumns.geometry_type_name = geometryType.toUpperCase();\r\n                                    geometryColumns.z = _features[0].getGeometryStride();\r\n                                    geometryColumns.m = 2;\r\n                                    geometryColumns.srs_id = srs_id;\r\n                                    i = 0;\r\n                                    const boundingBox = new geopackage.BoundingBox(bounds[0], bounds[2], bounds[1], bounds[3]);\r\n                                    myPackage.createFeatureTableWithGeometryColumns(geometryColumns, boundingBox, srs_id, columns)\r\n                                    //geopackage.createFeatureTableWithDataColumnsAndBoundingBox(myPackage, tableName, geometryColumns, columns, null, boundingBox, srs_id)\r\n                                    .then(function () {\r\n                                        const featureDao = myPackage.getFeatureDao(tableName);\r\n                                        var wkx = require('wkx');\r\n                                        for (let i = 0; i < _features.length; i++) {\r\n                                            const feature = _features[i];\r\n                                            const featureRow = featureDao.newRow();\r\n                                            const geometryData = new geopackage.GeometryData();\r\n                                            geometryData.setSrsId(srs_id);\r\n                                            const geometry = wkx.Geometry.parse('SRID=' + srs_id + ';' + (new ol.format.WKT().writeFeature(feature.wrap.feature)));\r\n                                            geometryData.setGeometry(geometry);\r\n                                            featureRow.setGeometry(geometryData);\r\n                                            if (_features[i].hasOwnProperty(\"id\") || _features[i].hasOwnProperty(\"ID\"))\r\n                                                featureRow.setValueWithColumnName(pkColumnName, typeof (feature.id) === \"string\" ? feature.id.substring(feature.id.lastIndexOf(\".\") + 1) : feature.id);    \r\n                                            else if (_features[i].data.hasOwnProperty(\"id\") || _features[i].data.hasOwnProperty(\"ID\"))\r\n                                                featureRow.setValueWithColumnName(pkColumnName, typeof (feature.id) === \"string\" ? feature.id.substring(feature.id.lastIndexOf(\".\") + 1) : feature.id);\r\n                                            for (var y in (feature.data || feature.attributes)) {\r\n                                                var fieldName = _features[0].attributes && _features[0].attributes[y] ? _features[0].attributes[x].name : y;\r\n                                                if (fieldName.toLowerCase() === 'id') continue;\r\n                                                var fieldValue = feature.data[fieldName];\r\n                                                featureRow.setValueWithColumnName(fieldName, fieldValue);\r\n                                            }\r\n                                            if (featureDao.columns.indexOf(\"name\")>=0 && !feature.data[\"name\"]) {\r\n                                                featureRow.setValueWithColumnName(\"name\", feature.getStyle().label);\r\n                                            }\r\n\r\n                                            featureDao.create(featureRow);\r\n                                        }\r\n                                        resolve();\r\n                                    })\r\n\r\n\r\n                                }));\r\n                            }\r\n                        }\r\n                        \r\n                        Promise.all(arrPromises).then(function (resolves) {\r\n                            myPackage.export(function (empty, data) {\r\n                                TC.Util.downloadFile(options.fileName + \".gpkg\", \"application/geopackage+sqlite3\", data);\r\n                                loadingCtl && loadingCtl.removeWait(waitId);\r\n                            })\r\n                        });\r\n                    });\r\n                });\r\n\r\n            });\r\n            return\r\n        }\r\n        const data = self.wrap.exportFeatures(features, options);\r\n        const mimeType = TC.Consts.mimeType[options.format];\r\n        if (format === TC.Consts.format.KMZ) {\r\n            TC.loadJS(!window.JSZip, TC.apiLocation + 'lib/jszip/jszip', async function () {\r\n                const zip = new JSZip();\r\n                let fileName = TC.Util.replaceSpecialCharacters(options.fileName || TC.getUID());\r\n                zip.file(fileName + \".kml\", data);\r\n                zip.generateAsync({ type: \"blob\", mimeType: mimeType }).then(function (blob) {\r\n                    filename = fileName + \".kmz\";\r\n                    TC.Util.downloadBlob(filename, blob);\r\n                    loadingCtl && loadingCtl.removeWait(waitId);\r\n                });            \r\n            });\r\n        }\r\n        else {\r\n            TC.Util.downloadFile((options.fileName || TC.getUID()) + '.' + format.toLowerCase(), mimeType, data);\r\n            loadingCtl && loadingCtl.removeWait(waitId);\r\n        }\r\n    };\r\n\r\n    mapProto.exportControlStates = function () {\r\n        const self = this;\r\n\r\n        return self.controls\r\n            .map(function (ctl) {\r\n                return ctl.exportState();\r\n            })\r\n            .filter(function (state) {\r\n                // Quitamos los estados nulos o vacos\r\n                if (state) {\r\n                    for (var key in state) {\r\n                        if (state.hasOwnProperty(key)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n    };\r\n\r\n    mapProto.importControlStates = function (controlStates) {\r\n        const self = this;\r\n\r\n        controlStates.forEach(function (state) {\r\n            const ctl = self.getControlById(state.id);\r\n            if (ctl) {\r\n                self.loaded(function () {\r\n                    ctl.importState(state);\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n    var toastContainerClass = 'tc-toast-container';\r\n    var toastClass = 'tc-toast';\r\n    var toasts = {};\r\n    var toastHide = function () {\r\n        const toast = this;\r\n        var container = toast;\r\n        do {\r\n            container = container.parentElement;\r\n        }\r\n        while (container && !container.matches('.' + toastContainerClass));\r\n        const text = toast.innerHTML;\r\n        toast.classList.add(TC.Consts.classes.HIDDEN);\r\n        if (toasts[text] !== undefined) {\r\n            toasts[text] = undefined;\r\n        }\r\n        setTimeout(function () {\r\n            if (toast.parentElement) {\r\n                toast.parentElement.removeChild(toast);\r\n            }\r\n            if (container && !container.querySelector('.' + toastClass) && container.parentElement) {\r\n                container.parentElement.removeChild(container);\r\n            }\r\n        }, 1000);\r\n    };\r\n\r\n    mapProto.toastHide = function (text) {\r\n        var toastInfo = toasts[text];\r\n        if (toastInfo) {\r\n            clearTimeout(toastInfo.timeout);\r\n            if (toastInfo.toast && toastInfo.toast.parentElement) {\r\n                toastInfo.toast.parentElement.removeChild(toastInfo.toast);\r\n            }\r\n            toastInfo.toast = null;\r\n        }\r\n    };\r\n\r\n    mapProto.toast = function (text, options) {\r\n        const self = this;\r\n        var opts = options || {\r\n        };\r\n        var duration = opts.duration || TC.Cfg.toastDuration;\r\n        var toastInfo = toasts[text];\r\n        if (toastInfo) {\r\n            clearTimeout(toastInfo.timeout);\r\n            if (toastInfo.toast && toastInfo.toast.parentElement) {\r\n                toastInfo.toast.parentElement.removeChild(toastInfo.toast);\r\n            }\r\n            toastInfo.toast = null;\r\n        }\r\n        var container = self.div.querySelector('.' + toastContainerClass);\r\n        if (!container) {\r\n            container = document.createElement('div');\r\n            container.classList.add(toastContainerClass);\r\n            (opts.container ? opts.container : self.div).appendChild(container);\r\n        }\r\n        const toast = document.createElement('div');\r\n        const span = document.createElement('span');\r\n        toast.classList.add(toastClass);\r\n        toast.appendChild(span);\r\n        const p = document.createElement('p');\r\n        p.innerHTML = text;\r\n        toast.appendChild(p);\r\n        toast.addEventListener(TC.Consts.event.CLICK, toastHide, { passive: true });\r\n        container.appendChild(toast);\r\n        toastInfo = toasts[text] = {\r\n            toast: toast\r\n        };\r\n\r\n        var className = '';\r\n        switch (opts.type) {\r\n            case TC.Consts.msgType.INFO:\r\n                className = TC.Consts.classes.INFO;\r\n                break;\r\n            case TC.Consts.msgType.WARNING:\r\n                className = TC.Consts.classes.WARNING;\r\n                break;\r\n            case TC.Consts.msgType.ERROR:\r\n                className = TC.Consts.classes.ERROR;\r\n                break;\r\n        }\r\n        if (className.length) {\r\n            toastInfo.toast.classList.add(className);\r\n        }\r\n\r\n        toastInfo.timeout = setTimeout(function () {\r\n            toastHide.call(toastInfo.toast);\r\n        }, duration);\r\n    };\r\n\r\n    // iPad iOS7 bug fix\r\n    var mapHeightNeedsFix = false;\r\n    var setHeightFix = function (div) {\r\n        if (/iPad/i.test(navigator.userAgent)) {\r\n            var ih = window.innerHeight;\r\n            var mh = div.getBoundingClientRect.height;\r\n            var dh = matchMedia('only screen and (orientation : landscape)').matches ? 20 : 0;\r\n            if (mh === ih + dh) {\r\n                mapHeightNeedsFix = true;\r\n            }\r\n        }\r\n        var fix = function () {\r\n            div.classList.toggle(TC.Consts.classes.IPAD_IOS7_FIX, matchMedia('only screen and (orientation : landscape)').matches);\r\n        };\r\n        if (mapHeightNeedsFix) {\r\n            fix();\r\n            window.addEventListener('resize', fix);\r\n        }\r\n        else {\r\n            window.removeEventListener('resize', fix);\r\n        }\r\n    };\r\n\r\n    var isRaster = function (layer) {\r\n        return typeof layer === 'string' || (layer.type !== TC.Consts.layerType.VECTOR && layer.type !== TC.Consts.layerType.KML && layer.type !== TC.Consts.layerType.WFS);\r\n    };\r\n\r\n    mapProto.exportImage = function () {\r\n        var self = this;\r\n        var result = null;\r\n        var errorMsg = 'El mapa actual no es compatible con la exportacin de imgenes';\r\n        var canvas = self.wrap.getViewport({ synchronous: true }).getElementsByTagName('canvas')[0];\r\n        if (canvas && self.options.crossOrigin) {\r\n            try {\r\n                result = canvas.toDataURL();\r\n            }\r\n            catch (e) {\r\n                TC.error(errorMsg + ': ' + e.message);\r\n            }\r\n        }\r\n        else {\r\n            TC.error(errorMsg);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    mapProto.getElevationTool = function () {\r\n        const self = this;\r\n        if (!self.elevation && !self.options.elevation) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (self.elevation) {\r\n            return Promise.resolve(self.elevation);\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            TC.loadJS(\r\n                !TC.tool || !TC.tool.Elevation,\r\n                TC.apiLocation + 'TC/tool/Elevation',\r\n                function () {\r\n                    if (!self.options.elevation) {\r\n                        self.elevation = null;\r\n                    }\r\n                    else {\r\n                        const elevationOptions = typeof self.options.elevation === 'boolean' ? {} : self.options.elevation;\r\n                        if (elevationOptions.services && self.options.googleMapsKey) {\r\n                            elevationOptions.services = elevationOptions.services.map(function (service) {\r\n                                const isString = typeof service === 'string';\r\n                                const serviceName = isString ? service : service.name\r\n                                if (serviceName === 'elevationServiceGoogle') {\r\n                                    return TC.Util.extend({\r\n                                        name: serviceName,\r\n                                        googleMapsKey: self.options.googleMapsKey\r\n                                    }, isString ? {} : service);\r\n                                }\r\n                                return service;\r\n                            });\r\n                        }\r\n                        self.elevation = new TC.tool.Elevation(elevationOptions);\r\n                    }\r\n                    resolve(self.elevation);\r\n                }\r\n            );\r\n        });\r\n    };\r\n\r\n\r\n    const _checkMaxFeatures = function (numMaxfeatures, urlData, data) {\r\n        return new Promise(function (resolve) {\r\n            urlData.mapLayer.toolProxification.fetchXML(urlData.url, {\r\n                data: data,\r\n                contentType: 'application/xml',\r\n                type: 'POST'\r\n            }).then(function (response) {\r\n                if (response instanceof XMLDocument) {\r\n                    const exception = response.querySelector(\"ExceptionReport Exception\")\r\n                    if (exception) {\r\n                        resolve({\r\n                            errors: [{\r\n                                key: TC.Consts.WFSErrors.INDETERMINATE,\r\n                                params: {\r\n                                    err: exception.getAttribute(\"exceptionCode\"), errorThrown: exception.querySelector(\"ExceptionText\").textContent\r\n                                }\r\n                            }]\r\n                        })\r\n                        return;\r\n                    }\r\n                }\r\n                var featFounds = parseInt(response.querySelector(\"FeatureCollection\").getAttribute(\"numberMatched\") || response.querySelector(\"FeatureCollection\").getAttribute(\"numberOfFeatures\"), 10);\r\n                if (isNaN(featFounds) || featFounds > parseInt(numMaxfeatures, 10)) {\r\n                    resolve({\r\n                        errors: [{\r\n                            key: TC.Consts.WFSErrors.MAX_NUM_FEATURES\r\n                        }]\r\n                    });\r\n                    return;\r\n                }\r\n                else if (featFounds === 0) {\r\n                    resolve({\r\n                        errors: [{\r\n                            key: TC.Consts.WFSErrors.NO_FEATURES\r\n                        }]\r\n                    });\r\n                    return;\r\n                }\r\n                else\r\n                    resolve(featFounds);\r\n\r\n            }).catch(function (e) {\r\n                //return Promise.reject(error);\r\n\r\n                resolve({\r\n                    errors: [{\r\n                        key: TC.Consts.WFSErrors.INDETERMINATE,\r\n                        params: { err: e.name, errorThrown: e.message }\r\n                    }]\r\n                });\r\n                return;\r\n            });\r\n\r\n            //TC.ajax({\r\n            //    url: url,\r\n            //    data: data,\r\n            //    contentType: 'application/xml',\r\n            //    responseType: 'application/xml',\r\n            //    method: 'POST'\r\n            //}).then(function (response) {\r\n            //    const responseData = response.data;\r\n            //    if (responseData instanceof XMLDocument) {\r\n            //        const exception = responseData.querySelector(\"ExceptionReport Exception\")\r\n            //        if (exception) {\r\n            //            resolve({\r\n            //                errors: [{\r\n            //                    key: TC.Consts.WFSErrors.INDETERMINATE,\r\n            //                    params: {\r\n            //                        err: exception.getAttribute(\"exceptionCode\"), errorThrown: exception.querySelector(\"ExceptionText\").textContent\r\n            //                    }\r\n            //                }]\r\n            //            })\r\n            //            return;\r\n            //        }\r\n            //    }\r\n            //    var featFounds = parseInt(responseData.querySelector(\"FeatureCollection\").getAttribute(\"numberMatched\") || responseData.querySelector(\"FeatureCollection\").getAttribute(\"numberOfFeatures\"), 10);                \r\n            //    if (isNaN(featFounds) || featFounds > parseInt(numMaxfeatures, 10)) {\r\n            //        resolve({\r\n            //            errors: [{\r\n            //                key: TC.Consts.WFSErrors.MAX_NUM_FEATURES\r\n            //            }]\r\n            //        });\r\n            //        return;\r\n            //    }\r\n            //    else if (featFounds === 0) {\r\n            //        resolve({\r\n            //            errors: [{\r\n            //                key: TC.Consts.WFSErrors.NO_FEATURES\r\n            //            }]\r\n            //        });\r\n            //        return;\r\n            //    }\r\n            //    else\r\n            //        resolve(featFounds);\r\n\r\n            //}, function (e) {\r\n            //    resolve({\r\n            //        errors: [{\r\n            //            key: TC.Consts.WFSErrors.INDETERMINATE,\r\n            //            params: { err: e.name, errorThrown: e.message }\r\n            //        }]\r\n            //    });\r\n            //    return;\r\n            //});\r\n        });\r\n    };\r\n\r\n    const _makePostCall = function (objLayer, data) {\r\n        return new Promise(function (resolve) {\r\n            objLayer.mapLayer.toolProxification.fetch(objLayer.url, {\r\n                data: data,\r\n                contentType: 'application/xml',\r\n                type: 'POST'\r\n            }).then(function (response) {\r\n                if (response instanceof XMLDocument) {\r\n                    const exception = response.querySelector(\"ExceptionReport Exception\")\r\n                    if (exception) {\r\n                        resolve({\r\n                            errors: [{\r\n                                key: TC.Consts.WFSErrors.INDETERMINATE,\r\n                                params: {\r\n                                    err: exception.getAttribute(\"exceptionCode\"), errorThrown: exception.querySelector(\"ExceptionText\").textContent\r\n                                }\r\n                            }]\r\n                        })\r\n                        return;\r\n                    }\r\n                }\r\n                resolve({ response: response });\r\n            }).catch(function (e) {\r\n                resolve({\r\n                    errors: [{\r\n                        key: TC.Consts.WFSErrors.INDETERMINATE,\r\n                        params: { err: e.name, errorThrown: e.message }\r\n                    }]\r\n                });\r\n                return;\r\n            });\r\n        });\r\n    };\r\n\r\n    const magicFunction = function (layer, availableLayers, filter) {\r\n        //obtenemos el describe featuretype de cada capa\r\n        return new Promise(async function (resolve, reject) {\r\n            try {\r\n                var response = await layer.describeFeatureType(availableLayers);\r\n            }\r\n            catch (error) {\r\n                reject(error);\r\n                return;\r\n            }\r\n            var returnObject = {};\r\n            if (availableLayers.length === 1) {\r\n                var obj = {};\r\n                obj[availableLayers[0]] = response;\r\n                response = obj;\r\n            }\r\n            //buscamos las geometras por cada respuesta\r\n            for (var layerName in response) {\r\n                let _filter;\r\n                var geometryFields = [];\r\n                for (var k in response[layerName]) {\r\n                    if (TC.Util.isGeometry(response[layerName][k].type) && !response[layerName][k].nillable && !response[layerName][k].minOccurs) {\r\n                        //if (/^gml:\\w+PropertyType$/.test(response[layerName][k].type) && !response[layerName][k].nillable && !response[layerName][k].minOccurs) {\r\n                        geometryFields.push(k)\r\n                    }\r\n                }\r\n                //Si solo hay un campo de tipo geometra bsucamos recursivamente entre en los filtros logicos And y or a la caza de filtros espaciales\r\n                //para poner el nombre de la geometra\r\n                if (geometryFields.length <= 1) {\r\n                    var recursive = (filter, geomName) => {\r\n                        if (filter instanceof TC.filter.LogicalNary)\r\n                            filter.conditions.forEach((condition) => {\r\n                                recursive(condition, geomName)\r\n                            })\r\n                        else if (filter instanceof TC.filter.Spatial) {\r\n                            filter.geometryName = geomName;\r\n                            return filter;\r\n                        }\r\n                    };\r\n                    _filter = Object.assign(new filter.constructor, recursive(filter, geometryFields.length === 0 ? null : geometryFields[0]))\r\n                }\r\n                //Si has mas de un campo de tipo geometra bsucamos recursivamente entre en los filtros logicos And y or a la caza de filtros espaciales\r\n                //para duplicar el filtro con los nombres de las geometrias y los emvolvemos en un filtro OR\r\n                else if (geometryFields.length > 1) {\r\n                    var recursive = (filter, geomNames) => {\r\n                        if (filter instanceof TC.filter.LogicalNary)\r\n                            filter.conditions.forEach((condition) => {\r\n                                recursive(condition, geomNames);\r\n                            })\r\n                        else if (filter instanceof TC.filter.Spatial) {\r\n                            return TC.filter.or.apply(null, geomNames.reduce((acc, curr) => { acc.push(new TC.filter[filter.getTagName()](curr, filter.geometry, filter.srsName)); return acc }, []))\r\n                        }\r\n                    };\r\n                    _filter = Object.assign(new filter.constructor, recursive(filter, geometryFields));\r\n                }\r\n                //ahora construimos el objeto que de vuelta\r\n                returnObject[layerName] = _filter;\r\n            }\r\n            resolve(returnObject);\r\n\r\n        });\r\n    };\r\n\r\n    mapProto.extractFeatures = function (options) {\r\n        const self = this;\r\n        const arrPromises = [];\r\n        options = options || {};\r\n        const filter = options.filter;\r\n        const outputFormat = options.outputFormat;\r\n        const download = options.download;\r\n        const layersToExtract = options.layers || self.layers;\r\n\r\n        const services = {};\r\n\r\n        const _getServiceTitle = function (service) {\r\n            const mapLayer = service.mapLayers[0];\r\n            return service.title || service.mapLayers.reduce(function (prev, cur) {\r\n                return prev || cur.title;\r\n            }, '') || (mapLayer.tree && mapLayer.tree.title) || mapLayer.capabilities.Service.Title;\r\n        };\r\n\r\n\r\n        const getCRS = function () {\r\n            if (download && (outputFormat === TC.Consts.mimeType.JSON || outputFormat === TC.Consts.mimeType.KML))\r\n                return TC.Consts.SRSDOWNLOAD_GEOJSON_KML;\r\n            return self.getCRS();\r\n        };\r\n        const _postOrDownload = function (objlayer, data) {\r\n            return new Promise(function (resolve) {\r\n                if (!download) {\r\n                    _makePostCall(objlayer, data).then(function (response) {\r\n                        if (response.errors && response.errors.length > 0) {\r\n                            response.errors[0].params[\"serviceTitle\"] = service.mapLayers.reduce(function (prev, cur) {\r\n                                return prev || cur.title;\r\n                            }, '') || _getServiceTitle(service);\r\n                            resolve(response);\r\n                        }\r\n                        else {\r\n                            resolve(response);\r\n                        }\r\n                    })\r\n                }\r\n                else {\r\n                    objlayer.mapLayer.toolProxification.cacheHost.getAction(objlayer.url).then(function (cacheAction) {\r\n                        resolve({\r\n                            url: cacheAction.action(objlayer.url),\r\n                            data: data\r\n                        });\r\n                    })\r\n\r\n\r\n                }\r\n            });\r\n        };\r\n        layersToExtract.forEach(function (layer) {\r\n            if (!layer.getVisibility() || self.workLayers.indexOf(layer) < 0 || layer.type !== TC.Consts.layerType.WMS) {\r\n                return;\r\n            }\r\n            var availableLayers = layer.getDisgregatedLayerNames() || layer.availableNames;\r\n            const url = layer.url.toLowerCase();\r\n            var serviceObj = services[url];\r\n            if (!serviceObj) {\r\n                serviceObj = services[url] = {\r\n                    url: url,\r\n                    layers: [],\r\n                    mapLayers: [layer],\r\n                    layerNames: []\r\n                };\r\n            }\r\n            for (var i = 0; i < availableLayers.length; i++) {\r\n                var name = availableLayers[i];\r\n                //URI:se quita la exclusion de capas no visibles por escala\r\n                /*if (!layer.isVisibleByScale(name) && !download)\r\n                    continue;*/\r\n                if (!layer.wrap.getInfo(name).queryable)\r\n                    continue;\r\n                serviceObj.layerNames.push(name);\r\n                var path = layer.getPath(name);\r\n                serviceObj.layers.push({\r\n                    name: name,\r\n                    title: path[path.length - 1],\r\n                    path: path.slice(1),\r\n                    features: []\r\n                });\r\n            }\r\n            if (serviceObj.layerNames.length == 0)\r\n                return;\r\n            if (typeof (serviceObj.request) !== \"undefined\") {\r\n                return;\r\n            }\r\n            serviceObj.request = serviceObj.request || layer.getWFSCapabilities(); //WFSCapabilities.Promises(url);\r\n            arrPromises.push(new Promise(function (resolve, reject) {\r\n                serviceObj.request.then(function (capabilities) {\r\n                    var service = null;\r\n                    var errors = [];\r\n                    for (var url in services)\r\n                        if (services[url].request && services[url].request == serviceObj.request) {\r\n                            service = services[url];\r\n                        }\r\n                    var _numMaxFeatures = null;\r\n                    var layerList = service.layerNames;\r\n                    if (!(layerList instanceof Array) || !layerList.length) return;//condici\\u00f3n de salida\r\n                    //comprobamos que tiene el getfeature habilitado\r\n                    if (typeof (capabilities.Operations.GetFeature) === \"undefined\") {\r\n                        errors.push({ key: TC.Consts.WFSErrors.GETFEATURE_NOT_AVAILABLE, params: { serviceTitle: _getServiceTitle(service) } })\r\n                        resolve({ \"errors\": errors });\r\n                        return;\r\n                    }\r\n                    var availableLayers = [];\r\n                    for (var i = 0; i < layerList.length; i++) {\r\n                        //Comprbamos si la capa en el WMS tiene el mimso nombre que en el WFS\r\n                        var layer = layerList[i];\r\n                        //quitamos los ultimos caracteres que sean \"_\" , cosas de Idena\r\n                        while (layer[layer.length - 1] === \"_\") {\r\n                            layer = layer.substring(0, layer.lastIndexOf(\"_\"));\r\n                        }\r\n                        if (!capabilities.FeatureTypes.hasOwnProperty(layer.substring(layerList[i].indexOf(\":\") + 1))) {\r\n                            var titles = service.mapLayers[0].getPath(layer.substring(layerList[i].indexOf(\":\") + 1));\r\n                            errors.push({ key: TC.Consts.WFSErrors.LAYERS_NOT_AVAILABLE, params: { serviceTitle: _getServiceTitle(service), \"layerName\": titles[titles.length - 1] } });\r\n                            continue;\r\n                        }\r\n                        if (availableLayers.indexOf(layer) < 0)\r\n                            availableLayers.push(layer);\r\n                    }\r\n                    if (availableLayers.length == 0) {\r\n                        errors.push({ key: TC.Consts.WFSErrors.NO_VALID_LAYERS, params: { serviceTitle: _getServiceTitle(service) } });\r\n                        resolve({ \"errors\": errors });\r\n                        return;\r\n                    }\r\n                    if (capabilities.Operations.GetFeature.CountDefault)\r\n                        _numMaxFeatures = capabilities.Operations.GetFeature.CountDefault.DefaultValue;\r\n                    //comprobamos si soporta querys    \r\n                    if (\r\n                        (capabilities.version === \"1.0.0\" && !capabilities.Operations.GetFeature.Operations.hasOwnProperty(\"Query\"))\r\n                        ||\r\n                        ((capabilities.version === \"2.0.0\" || capabilities.version === \"1.1.0\") && capabilities.Operations.QueryExpressions.indexOf(\"wfs:Query\") < 0)\r\n                    ) {\r\n                        errors.push({ key: TC.Consts.WFSErrors.QUERY_NOT_AVAILABLE, params: { serviceTitle: _getServiceTitle(service) } });\r\n                        resolve({ \"errors\": errors });\r\n                        return;\r\n                    }\r\n                    var url = (capabilities.Operations.GetFeature.DCPType ? capabilities.Operations.GetFeature.DCPType[1].HTTP.Post.onlineResource : capabilities.Operations.GetFeature.DCP.HTTP.Post[\"href\"]);\r\n\r\n                    Promise.all([\r\n                        magicFunction(service.mapLayers[0], availableLayers, filter)//clonar filtro\r\n                    ]).then(function (response) {\r\n                        var filter = response[0]; //1\r\n                        if (_numMaxFeatures) {\r\n                            _checkMaxFeatures(_numMaxFeatures, { url: url, mapLayer: service.mapLayers[0] }, TC.Util.WFSQueryBuilder(filter, null, capabilities, outputFormat, true, getCRS())).then(function (response) {\r\n                                if (response.errors && response.errors.length > 0) {\r\n                                    switch (response.errors[0].key) {\r\n                                        case TC.Consts.WFSErrors.INDETERMINATE:\r\n                                            response.errors[0].params[\"serviceTitle\"] = service.mapLayers.reduce(function (prev, cur) {\r\n                                                return prev || cur.title;\r\n                                            }, '') || _getServiceTitle(service);\r\n                                            break;\r\n                                        case TC.Consts.WFSErrors.MAX_NUM_FEATURES:\r\n                                            response.errors[0][\"params\"] = { limit: _numMaxFeatures, serviceTitle: _getServiceTitle(service) };\r\n                                            break;\r\n                                        case TC.Consts.WFSErrors.NO_FEATURES:\r\n                                            response.errors[0][\"params\"] = { serviceTitle: _getServiceTitle(service) };\r\n                                            break;\r\n                                    }\r\n                                    resolve(response);\r\n                                }\r\n                                else\r\n                                    _postOrDownload({ url: url, mapLayer: service.mapLayers[0] }, TC.Util.WFSQueryBuilder(filter, null, capabilities, (download ? outputFormat : TC.Consts.mimeType.JSON), false, getCRS())).then(function (response) {\r\n                                        resolve(Object.assign({ service: service, errors: errors }, response));\r\n                                    });\r\n                            });\r\n                        }\r\n                        else {\r\n                            _postOrDownload({ url: url, mapLayer: service.mapLayers[0] }, TC.Util.WFSQueryBuilder(filter, null, capabilities, (download ? outputFormat : TC.Consts.mimeType.JSON), false, getCRS())).then(function (response) {\r\n                                resolve(Object.assign({ service: service, errors: errors }, response))\r\n\r\n                            });\r\n                        }\r\n                    }).catch(function (e) {\r\n                        resolve({\r\n                            errors: [{\r\n                                key: TC.Consts.WFSErrors.INDETERMINATE,\r\n                                params: { err: e.name, errorThrown: e.message, serviceTitle: _getServiceTitle(service) }\r\n                            }]\r\n                        });\r\n                    });\r\n                }, function (e) {\r\n                    var service = null;\r\n                    for (var title in services)\r\n                        if (services[title].request && services[title].request === serviceObj.request) {\r\n                            service = services[title];\r\n                        }\r\n                    resolve({ errors: [{ key: TC.Consts.WFSErrors.GETCAPABILITIES, params: { err: e.name, serviceTitle: _getServiceTitle(service) } }] });\r\n                });\r\n            }));\r\n        });\r\n        return arrPromises;\r\n    };\r\n\r\n    mapProto.updateSize = function () {\r\n        this.wrap.updateSize();\r\n    };\r\n\r\n    mapProto.linkTo = function (map) {\r\n        this.wrap.linkTo(map);\r\n    };\r\n\r\n})();\r\n\r\n/**\r\n * rbol de capas del mapa.\r\n * Esta clase no tiene constructor.\r\n * @class TC.LayerTree\r\n * @static\r\n */\r\n/**\r\n * Lista de rboles de (objetos de la clase {{#crossLink \"TC.layer.LayerTree\"}}{{/crossLink}}) de todas las capas base del mapa.\r\n * @property baseLayers\r\n * @type array\r\n */\r\n/**\r\n * Lista de rboles de (objetos de la clase {{#crossLink \"TC.layer.LayerTree\"}}{{/crossLink}}) de todas las capas de trabajo del mapa.\r\n * @property workLayers\r\n * @type array\r\n */\r\n"]}