{"version":3,"sources":["control/MapContents.js"],"names":["TC","control","Control","syncLoadJS","apiLocation","MapContents","apply","this","arguments","layerTrees","inherit","ctlProto","prototype","CLASS","render","callback","options","self","_set1stRenderPromise","map","renderData","Util","extend","getLayerTree","addUIEventListeners","Promise","reject","register","resolve","all","call","renderPromise","then","i","len","layers","length","updateLayerTree","on","Consts","event","ZOOM","PROJECTIONCHANGE","updateScale","UPDATEPARAMS","e","layer","names","containsName","node","result","indexOf","name","children","id","update","LAYERVISIBILITY","updateLayerVisibility","LAYERADD","VECTORUPDATE","FEATUREADD","FEATURESADD","_updateLayerTreeTimeout","clearTimeout","setTimeout","workLayers","LAYERREMOVE","removeLayer","LAYERORDER","updateLayerOrder","oldIndex","newIndex","LAYERERROR","onErrorLayer","catch","err","Error","getTree","oldIdx","newIdx","collection","currentElm","previousElm","elms","getLayerUIElements","l","j","jj","elm","dataset","layerId","insertAdjacentElement","parentElement","firstChild","liCollection","li","removeChild","div","querySelector","classList","remove","classes","HIDDEN","styleLegendImage","img","getAttribute","imgSrc","toolProxification","tool","Proxification","proxify","method","getLegendGraphicImage","src","error","test","watch","colorStr","style","color","openIdx","closeIdx","substr","split","component","parseInt","toString","replace","fontFamily","fontSize","params","sld_body","addURLParameters","fetchImage","statusText"],"mappings":"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","sourcesContent":["TC.control = TC.control || {};\r\n\r\nif (!TC.Control) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Control');\r\n}\r\n\r\nTC.control.MapContents = function () {\r\n    var self = this;\r\n\r\n    TC.Control.apply(self, arguments);\r\n\r\n    self.layerTrees = {};\r\n};\r\n\r\nTC.inherit(TC.control.MapContents, TC.Control);\r\n\r\n(function () {\r\n    var ctlProto = TC.control.MapContents.prototype;\r\n\r\n    ctlProto.CLASS = 'tc-ctl-mc';\r\n\r\n    ctlProto.render = function (callback, options) {\r\n        const self = this;\r\n        return self._set1stRenderPromise(self.map ? self.renderData(options ? TC.Util.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {\r\n            self.addUIEventListeners();\r\n            if (typeof callback === 'function') {\r\n                callback();\r\n            }\r\n        }) : Promise.reject());\r\n    };\r\n\r\n    ctlProto.register = function (map) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {\r\n                for (var i = 0, len = map.layers.length; i < len; i++) {\r\n                    self.updateLayerTree(map.layers[i]);\r\n                }\r\n\r\n                map\r\n                    .on(TC.Consts.event.ZOOM + ' ' + TC.Consts.event.PROJECTIONCHANGE, function () {\r\n                        self.updateScale();\r\n                    })\r\n                    .on(TC.Consts.event.UPDATEPARAMS, function (e) {\r\n                        const layer = e.layer;\r\n                        var names = layer.names;\r\n                        var containsName = function containsName(node) {\r\n                            var result = false;\r\n                            if (node) {\r\n                                if (names.indexOf(node.name) >= 0) {\r\n                                    result = true;\r\n                                }\r\n                                else {\r\n                                    for (var i = 0; i < node.children.length; i++) {\r\n                                        if (containsName(node.children[i])) {\r\n                                            result = true;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            return result;\r\n                        };\r\n                        if (containsName(self.layerTrees[layer.id]) || names.length === 0) {\r\n                            self.update();\r\n                        }\r\n                        else {\r\n                            self.updateLayerTree(layer);\r\n                        }\r\n                    })\r\n                    .on(TC.Consts.event.LAYERVISIBILITY, function (e) {\r\n                        self.updateLayerVisibility(e.layer);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERADD, function (e) {\r\n                        self.updateLayerTree(e.layer);\r\n                    })\r\n                    .on(TC.Consts.event.VECTORUPDATE + ' ' + TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {\r\n                        const layer = e.layer;\r\n                        // Se introduce un timeout porque pueden venir muchos eventos de este tipo seguidos y no tiene sentido actualizar con cada uno\r\n                        if (self._updateLayerTreeTimeout) {\r\n                            clearTimeout(self._updateLayerTreeTimeout);\r\n                        }\r\n                        self._updateLayerTreeTimeout = setTimeout(function () {\r\n                            if (self.map.workLayers.indexOf(layer) > -1) {\r\n                                // GLS: Validamos si la capa que ha provocado el evento sigue en worklayers, si es borrada debido a la espera del timeout el TOC puede reflejar capas que ya no están\r\n                                self.updateLayerTree(layer);\r\n                                delete self._updateLayerTreeTimeout;\r\n                            }\r\n                        }, 100);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERREMOVE, function (e) {\r\n                        self.removeLayer(e.layer);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERORDER, function (e) {\r\n                        self.updateLayerOrder(e.layer, e.oldIndex, e.newIndex);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERERROR, function (e) {\r\n                        self.onErrorLayer(e.layer);                                                    \r\n                    });\r\n\r\n                resolve(self);\r\n            }).catch(function (err) {\r\n                reject(err instanceof Error ? err : Error(err));\r\n            });\r\n        });\r\n    };\r\n\r\n    ctlProto.updateScale = function () {\r\n    };\r\n\r\n    ctlProto.updateLayerVisibility = function (layer) {\r\n    };\r\n\r\n    ctlProto.updateLayerTree = function (layer) {\r\n        this.layerTrees[layer.id] = layer.getTree();\r\n    };\r\n\r\n    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx, collection) {\r\n        const self = this;\r\n        if (oldIdx >= 0 && oldIdx !== newIdx) {\r\n            var currentElm, previousElm;\r\n            const elms = self.getLayerUIElements();\r\n\r\n            collection = collection || self.map.workLayers;\r\n\r\n            for (var i = collection.length - 1; i >= 0; i--) {\r\n                const l = collection[i];\r\n                previousElm = currentElm;\r\n                for (var j = 0, jj = elms.length; j < jj; j++) {\r\n                    const elm = elms[j];\r\n                    if (elm.dataset.layerId === l.id) {\r\n                        currentElm = elm;\r\n                        break;\r\n                    }\r\n                }\r\n                if (l === layer) {\r\n                    if (previousElm) {\r\n                        previousElm.insertAdjacentElement('afterend', currentElm);\r\n                    }\r\n                    else {\r\n                        currentElm.parentElement.firstChild.insertAdjacentElement('beforebegin', currentElm);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    ctlProto.removeLayer = function (layer) {\r\n        const self = this;\r\n        const liCollection = self.getLayerUIElements();\r\n        for (var i = 0, len = liCollection.length; i < len; i++) {\r\n            const li = liCollection[i];\r\n            if (li.dataset.layerId === layer.id) {\r\n                li.parentElement.removeChild(li);\r\n                break;\r\n            }\r\n        }\r\n        if (self.getLayerUIElements().length === 0) {\r\n            self.div.querySelector('.' + self.CLASS + '-empty').classList.remove(TC.Consts.classes.HIDDEN);\r\n        }\r\n    };\r\n\r\n    ctlProto.onErrorLayer = function (layer) { };\r\n\r\n    ctlProto.getLayerUIElements = function () {\r\n        return this.div.querySelector('ul').children;\r\n    };\r\n\r\n    var isGetLegendGraphic = function (url) {\r\n        return /[&?]REQUEST=getLegendGraphic/i.test(url);\r\n    };\r\n\r\n    /**\r\n     * Carga y le da estilo a la imagen de la leyenda.\r\n     * @param {string} requestMethod Si queremos pedir la imagen de la leyenda por POST, podemos especificarlo utilizando el parámetro requestMethod.\r\n     */\r\n    ctlProto.styleLegendImage = function (img, layer) {\r\n        if (!img.getAttribute('src')) {\r\n            var imgSrc = img.dataset.img;\r\n\r\n            const toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n            if (layer && layer.options.method && layer.options.method === \"POST\") {\r\n                layer.getLegendGraphicImage()\r\n                    .then(function (src) {\r\n                        img.src = src; // ya se ha validado en getLegendGraphicImage\r\n                    }).catch(function (err) {\r\n                        TC.error(err);\r\n                    });\r\n            } else {\r\n                if (isGetLegendGraphic(imgSrc)) {\r\n                    const watch = img.parentElement;\r\n                    // A\\u00f1adimos el par\\u00e1metro que define el estilo de los textos en la imagen\r\n                    var colorStr = watch.style.color;\r\n                    // Convertimos el color de formato rgb(r,g,b) a 0xRRGGBB\r\n                    var openIdx = colorStr.indexOf('(');\r\n                    var closeIdx = colorStr.indexOf(')');\r\n                    if (openIdx >= 0 && closeIdx > openIdx) {\r\n                        color = colorStr\r\n                            .substr(0, closeIdx)\r\n                            .substr(openIdx + 1)\r\n                            .split(',');\r\n                        colorStr = '0x';\r\n                        for (var i = 0; i < 3; i++) {\r\n                            var component = parseInt(color[i]).toString(16);\r\n                            colorStr += component.length === 1 ? '0' + component : component;\r\n                        }\r\n                    }\r\n                    else {\r\n                        colorStr.replace('#', '0x');\r\n                    }\r\n                    imgSrc += '&LEGEND_OPTIONS=fontName:' + watch.style.fontFamily +\r\n                        ';fontSize:' + parseInt(watch.style.fontSize) +\r\n                        ';fontColor:' + colorStr +\r\n                        ';fontAntiAliasing:true';\r\n                    if (layer.params && layer.params.sld_body) {\r\n                        imgSrc = TC.Util.addURLParameters(imgSrc, { sld_body: layer.params.sld_body });\r\n                    }\r\n\r\n                    toolProxification.fetchImage(imgSrc).then(function (img) {\r\n                        img.dataset.img = img.src;\r\n                    }).catch(function (err) {\r\n                        TC.error(err);\r\n                    });\r\n                }\r\n\r\n                toolProxification.fetchImage(imgSrc).then(function (i) {\r\n                    img.src = i.src;\r\n                }).catch(function (err) {\r\n                    TC.error(err.statusText);\r\n                });                \r\n            }\r\n        }\r\n    };\r\n\r\n})();"]}